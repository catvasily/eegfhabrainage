<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classes and functions for EEG data processing &mdash; eegfh 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=e031e9a9"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="EEG clinical reports processing" href="README_reports.html" />
    <link rel="prev" title="EEG preprocessing pipeline for FHA EDF dataset" href="README.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            eegfh
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">EEG preprocessing pipeline for FHA EDF dataset</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Classes and functions for EEG data processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-run_filtering_segmentation">run_filtering_segmentation.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run_filtering_segmentation.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-edf_preprocessing">edf_preprocessing.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.PreProcessing"><code class="docutils literal notranslate"><span class="pre">PreProcessing</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.filename"><code class="docutils literal notranslate"><span class="pre">PreProcessing.filename</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.conf_dict"><code class="docutils literal notranslate"><span class="pre">PreProcessing.conf_dict</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.target_channels"><code class="docutils literal notranslate"><span class="pre">PreProcessing.target_channels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.exclude_channels"><code class="docutils literal notranslate"><span class="pre">PreProcessing.exclude_channels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.target_frequency"><code class="docutils literal notranslate"><span class="pre">PreProcessing.target_frequency</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.raw"><code class="docutils literal notranslate"><span class="pre">PreProcessing.raw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.sfreq"><code class="docutils literal notranslate"><span class="pre">PreProcessing.sfreq</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.flat_parms"><code class="docutils literal notranslate"><span class="pre">PreProcessing.flat_parms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.bad_intervals"><code class="docutils literal notranslate"><span class="pre">PreProcessing.bad_intervals</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals"><code class="docutils literal notranslate"><span class="pre">PreProcessing.clean_intervals</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.__init__"><code class="docutils literal notranslate"><span class="pre">PreProcessing.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.create_intervals_data"><code class="docutils literal notranslate"><span class="pre">PreProcessing.create_intervals_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.extract_good"><code class="docutils literal notranslate"><span class="pre">PreProcessing.extract_good()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.flat_intervals"><code class="docutils literal notranslate"><span class="pre">PreProcessing.flat_intervals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.hyperventilation"><code class="docutils literal notranslate"><span class="pre">PreProcessing.hyperventilation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.photic_stimulation"><code class="docutils literal notranslate"><span class="pre">PreProcessing.photic_stimulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#edf_preprocessing.PreProcessing.save_edf"><code class="docutils literal notranslate"><span class="pre">PreProcessing.save_edf()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.assign_known_channel_types"><code class="docutils literal notranslate"><span class="pre">assign_known_channel_types()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.load_edf_data"><code class="docutils literal notranslate"><span class="pre">load_edf_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.read_edf"><code class="docutils literal notranslate"><span class="pre">read_edf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#edf_preprocessing.slice_edfs"><code class="docutils literal notranslate"><span class="pre">slice_edfs()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-individual_func">individual_func.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.prefilter_string"><code class="docutils literal notranslate"><span class="pre">prefilter_string()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.read_notch_info"><code class="docutils literal notranslate"><span class="pre">read_notch_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.safe_crop"><code class="docutils literal notranslate"><span class="pre">safe_crop()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.save_notch_info"><code class="docutils literal notranslate"><span class="pre">save_notch_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.select_chans"><code class="docutils literal notranslate"><span class="pre">select_chans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.set_channel_types"><code class="docutils literal notranslate"><span class="pre">set_channel_types()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#individual_func.write_mne_edf"><code class="docutils literal notranslate"><span class="pre">write_mne_edf()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-run_pyprep_ica">run_pyprep_ica.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run_pyprep_ica.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-do_pyprep">do_pyprep.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#do_pyprep.JSON_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_pyprep.Pipeline"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.conf_dict"><code class="docutils literal notranslate"><span class="pre">Pipeline.conf_dict</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.ch_groups"><code class="docutils literal notranslate"><span class="pre">Pipeline.ch_groups</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.raw"><code class="docutils literal notranslate"><span class="pre">Pipeline.raw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.__init__"><code class="docutils literal notranslate"><span class="pre">Pipeline.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.applyPipeline"><code class="docutils literal notranslate"><span class="pre">Pipeline.applyPipeline()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.filter_group"><code class="docutils literal notranslate"><span class="pre">Pipeline.filter_group()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.getRaw"><code class="docutils literal notranslate"><span class="pre">Pipeline.getRaw()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.ica"><code class="docutils literal notranslate"><span class="pre">Pipeline.ica()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.prep"><code class="docutils literal notranslate"><span class="pre">Pipeline.prep()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#do_pyprep.Pipeline.showplot"><code class="docutils literal notranslate"><span class="pre">Pipeline.showplot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-extract_hv_intervals">extract_hv_intervals.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extract_hv_intervals.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-extract_ps_intervals">extract_ps_intervals.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extract_ps_intervals.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-create_ps_events">create_ps_events.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create_ps_events.PREPROC_CONF_FILE"><code class="docutils literal notranslate"><span class="pre">PREPROC_CONF_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#create_ps_events.create_ps_events"><code class="docutils literal notranslate"><span class="pre">create_ps_events()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#create_ps_events.get_ps_frq"><code class="docutils literal notranslate"><span class="pre">get_ps_frq()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-run_src_reconstr">run_src_reconstr.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run_src_reconstr.JSON_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_src_reconstr.PYPREP_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">PYPREP_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_src_reconstr.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-add_virtual_channels">add_virtual_channels.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#add_virtual_channels.add_virtual_channels"><code class="docutils literal notranslate"><span class="pre">add_virtual_channels()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-do_src_reconstr">do_src_reconstr.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.beam_extract_label_time_course"><code class="docutils literal notranslate"><span class="pre">beam_extract_label_time_course()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.compute_beamformer_stc"><code class="docutils literal notranslate"><span class="pre">compute_beamformer_stc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.compute_roi_time_courses"><code class="docutils literal notranslate"><span class="pre">compute_roi_time_courses()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.compute_source_timecourses"><code class="docutils literal notranslate"><span class="pre">compute_source_timecourses()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.construct_noise_and_inv_cov"><code class="docutils literal notranslate"><span class="pre">construct_noise_and_inv_cov()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.encode_vertex_list"><code class="docutils literal notranslate"><span class="pre">encode_vertex_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.fwd_file_name"><code class="docutils literal notranslate"><span class="pre">fwd_file_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_beam_weights"><code class="docutils literal notranslate"><span class="pre">get_beam_weights()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_label_coms"><code class="docutils literal notranslate"><span class="pre">get_label_coms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_label_fwd"><code class="docutils literal notranslate"><span class="pre">get_label_fwd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_label_pca_weight"><code class="docutils literal notranslate"><span class="pre">get_label_pca_weight()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_label_src_idx"><code class="docutils literal notranslate"><span class="pre">get_label_src_idx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_label_wts"><code class="docutils literal notranslate"><span class="pre">get_label_wts()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.get_voxel_coords"><code class="docutils literal notranslate"><span class="pre">get_voxel_coords()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.ltc_file_name"><code class="docutils literal notranslate"><span class="pre">ltc_file_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.parse_vertex_list"><code class="docutils literal notranslate"><span class="pre">parse_vertex_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.read_roi_time_courses"><code class="docutils literal notranslate"><span class="pre">read_roi_time_courses()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#do_src_reconstr.write_roi_time_courses"><code class="docutils literal notranslate"><span class="pre">write_roi_time_courses()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-make_fsaverage_bem">make_fsaverage_bem.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#make_fsaverage_bem.make_fsaverage_bem"><code class="docutils literal notranslate"><span class="pre">make_fsaverage_bem()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-nearest_pos_def">nearest_pos_def.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nearest_pos_def.isPD"><code class="docutils literal notranslate"><span class="pre">isPD()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#nearest_pos_def.nearestPD"><code class="docutils literal notranslate"><span class="pre">nearestPD()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-run_welch">run_welch.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.PREPROC_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">PREPROC_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.get_data_folders"><code class="docutils literal notranslate"><span class="pre">get_data_folders()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.load_data"><code class="docutils literal notranslate"><span class="pre">load_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.plot_psd"><code class="docutils literal notranslate"><span class="pre">plot_psd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.read_welch_psd"><code class="docutils literal notranslate"><span class="pre">read_welch_psd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_welch.write_welch_psd"><code class="docutils literal notranslate"><span class="pre">write_welch_psd()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-run_cwt">run_cwt.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.CWT_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">CWT_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.DIST"><code class="docutils literal notranslate"><span class="pre">DIST</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.FITS"><code class="docutils literal notranslate"><span class="pre">FITS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.FitEW"><code class="docutils literal notranslate"><span class="pre">FitEW</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#run_cwt.FitEW.__init__"><code class="docutils literal notranslate"><span class="pre">FitEW.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.INPUT_JSON_FILE"><code class="docutils literal notranslate"><span class="pre">INPUT_JSON_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.PREPROC_CONFIG_FILE"><code class="docutils literal notranslate"><span class="pre">PREPROC_CONFIG_FILE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.cwt_process_a_channel"><code class="docutils literal notranslate"><span class="pre">cwt_process_a_channel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.estimate_parms"><code class="docutils literal notranslate"><span class="pre">estimate_parms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.fit_res"><code class="docutils literal notranslate"><span class="pre">fit_res()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.loglin_freqs"><code class="docutils literal notranslate"><span class="pre">loglin_freqs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run_cwt.plot_distr"><code class="docutils literal notranslate"><span class="pre">plot_distr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-tfdata">tfdata.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tfdata.TFData"><code class="docutils literal notranslate"><span class="pre">TFData</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.CHAN_DIM"><code class="docutils literal notranslate"><span class="pre">TFData.CHAN_DIM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.FRQ_DIM"><code class="docutils literal notranslate"><span class="pre">TFData.FRQ_DIM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.PARM_DIM"><code class="docutils literal notranslate"><span class="pre">TFData.PARM_DIM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.dim_names"><code class="docutils literal notranslate"><span class="pre">TFData.dim_names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.scan_id"><code class="docutils literal notranslate"><span class="pre">TFData.scan_id</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.ch_names"><code class="docutils literal notranslate"><span class="pre">TFData.ch_names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.freqs"><code class="docutils literal notranslate"><span class="pre">TFData.freqs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.parm_names"><code class="docutils literal notranslate"><span class="pre">TFData.parm_names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.data"><code class="docutils literal notranslate"><span class="pre">TFData.data</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.__init__"><code class="docutils literal notranslate"><span class="pre">TFData.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.get_fixed_f_slice"><code class="docutils literal notranslate"><span class="pre">TFData.get_fixed_f_slice()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.get_nearest_freq"><code class="docutils literal notranslate"><span class="pre">TFData.get_nearest_freq()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.read"><code class="docutils literal notranslate"><span class="pre">TFData.read()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.to_pandas"><code class="docutils literal notranslate"><span class="pre">TFData.to_pandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tfdata.TFData.write"><code class="docutils literal notranslate"><span class="pre">TFData.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-view_raw_eeg">view_raw_eeg.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-view_inflated_brain_data">view_inflated_brain_data.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#view_inflated_brain_data.expand_data_to_rois"><code class="docutils literal notranslate"><span class="pre">expand_data_to_rois()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#view_inflated_brain_data.plot_rr"><code class="docutils literal notranslate"><span class="pre">plot_rr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#view_inflated_brain_data.plot_vertices"><code class="docutils literal notranslate"><span class="pre">plot_vertices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#view_inflated_brain_data.view_inflated_brain_data"><code class="docutils literal notranslate"><span class="pre">view_inflated_brain_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-plot_alpha_power">plot_alpha_power.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-running_mean_std">running_mean_std.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#running_mean_std.RunningMeanSTD"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.__init__"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.counter"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.counter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.is_array"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.is_array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.mean"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.push"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.push()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.reset"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.reset()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.std"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.std()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#running_mean_std.RunningMeanSTD.var"><code class="docutils literal notranslate"><span class="pre">RunningMeanSTD.var()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="README_reports.html">EEG clinical reports processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="reports.html">Classes and functions for EEG reports processing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">eegfh</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Classes and functions for EEG data processing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/code.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="classes-and-functions-for-eeg-data-processing">
<h1>Classes and functions for EEG data processing<a class="headerlink" href="#classes-and-functions-for-eeg-data-processing" title="Permalink to this heading"></a></h1>
<p>Python code used for EEG records processing.</p>
<section id="module-run_filtering_segmentation">
<span id="run-filtering-segmentation-py"></span><h2>run_filtering_segmentation.py<a class="headerlink" href="#module-run_filtering_segmentation" title="Permalink to this heading"></a></h2>
<p><strong>A top level script for filtering, resampling and extracting good segments
from the EEG recordings.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="run_filtering_segmentation.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#run_filtering_segmentation.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output
data folders, and a flag indicating whether host is on CC cluster</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-edf_preprocessing">
<span id="edf-preprocessing-py"></span><h2>edf_preprocessing.py<a class="headerlink" href="#module-edf_preprocessing" title="Permalink to this heading"></a></h2>
<p><strong>Functions and classes used in the filtering and segmentation step.</strong></p>
<dl class="py data">
<dt class="sig sig-object py" id="edf_preprocessing.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'preproc_conf.json'</span></em><a class="headerlink" href="#edf_preprocessing.JSON_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Default name (without a path) for the JSON file with preprocessing parameters. It is expected
to reside in the same folder as the <em>edf_preprocessing.py</em> source file.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PreProcessing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notch_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flat_parms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing" title="Permalink to this definition"></a></dt>
<dd><p>The class’s aim is preprocessing clinical EEG recordings (in EDF format)
and make them a suitable input for a later analysis and ML applications.</p>
<p>The class instantiates a preprocessing object which
carries a Raw EDF file through a sequence of operations:</p>
<ol class="arabic simple">
<li><p>resample each recording’s signal to traget frequency</p></li>
<li><p>keeps only signal with frequencies in selected range</p></li>
<li><p>identifies timestamps of hyperventilation (HV), photic stimulation (PhS)
and flat (zero) signal (together - “bad” intervals)</p></li>
<li><p>extract EEG segment(s) of needed length from “good” intervals</p></li>
</ol>
<p>Then the object can save extracted segment(s) into new EDF files
OR return a Pandas DataFrame with data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> (<em>str</em>) – the EDF file pathname</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters.
The default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant.</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>target_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of mandatory channels to read from the EDF
file.</p></li>
<li><p><strong>exclude_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of channels to be excluded when reading
the EDF file.</p></li>
<li><p><strong>target_frequency</strong> (<em>int</em>) – the final EEG frequency after resampling</p></li>
<li><p><strong>lfreq</strong> (<em>float</em>) – lower frequency boundary of the signal to keep</p></li>
<li><p><strong>hfreq</strong> (<em>float</em>) – higher frequency boundary of the signal to keep</p></li>
<li><p><strong>notch_freq</strong> (<em>float</em>) – notch frequency (typically - power line frequency)</p></li>
<li><p><strong>flat_parms</strong> (<em>dict</em>) – parameters for flat intervals selection. Should contain the
following keys:
<em>‘flat_max_ptp’</em> - the channel’s amplitude max peak-to-peak value (in channel’s
units) for this channel to be marked as flat;
<em>‘bad_percent’</em> - min percentage of the time the channel’s peak
to peak is below the <em>‘flat_max_ptp’</em> threshold to be considered flat;
<em>‘min_duration’</em> - minimum interval in seconds for all consecutive samples to
be below the <em>‘flat_max_ptp’</em> to indicate a flat interval.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If both <em>conf_json</em> and <em>conf_dict</em>
are omitted in the constructor, the default settings will be read from <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> which should
be present in the same folder as the <em>edf_preprocessing.py</em>.</p></li>
<li><p>When not None, the explicitly specified parameter values will be used instead of the values
given by corresponding keys in <em>conf_json</em> or <em>conf_dict</em>.</p></li>
</ul>
</div>
<p><strong>Attributes</strong></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.filename">
<span class="sig-name descname"><span class="pre">filename</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.filename" title="Permalink to this definition"></a></dt>
<dd><p>EDF file path</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.conf_dict">
<span class="sig-name descname"><span class="pre">conf_dict</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.conf_dict" title="Permalink to this definition"></a></dt>
<dd><p>a dictionary with configuration parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.target_channels">
<span class="sig-name descname"><span class="pre">target_channels</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.target_channels" title="Permalink to this definition"></a></dt>
<dd><p>a list of mandatory channels to read from the EDF
file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.exclude_channels">
<span class="sig-name descname"><span class="pre">exclude_channels</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.exclude_channels" title="Permalink to this definition"></a></dt>
<dd><p>a list of channels to be excluded when reading
the EDF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.target_frequency">
<span class="sig-name descname"><span class="pre">target_frequency</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.target_frequency" title="Permalink to this definition"></a></dt>
<dd><p>the final EEG frequency after resampling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.raw" title="Permalink to this definition"></a></dt>
<dd><p>the raw EDF object</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mne.Raw</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.sfreq">
<span class="sig-name descname"><span class="pre">sfreq</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.sfreq" title="Permalink to this definition"></a></dt>
<dd><p>initial sampling frequency of EEG</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.flat_parms">
<span class="sig-name descname"><span class="pre">flat_parms</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.flat_parms" title="Permalink to this definition"></a></dt>
<dd><p>parameters for flat intervals selection (see above)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.bad_intervals">
<span class="sig-name descname"><span class="pre">bad_intervals</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.bad_intervals" title="Permalink to this definition"></a></dt>
<dd><p>a list of the [start, end] pairs with timestamps in seconds,
indicating starts and ends of bad intervals (HV, PhS, flat signal)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.clean_intervals">
<span class="sig-name descname"><span class="pre">clean_intervals</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.clean_intervals" title="Permalink to this definition"></a></dt>
<dd><p>a list of the [start, end] pairs with timestamps in seconds,
indicating starts and ends of segments to be extracted</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<p><strong>Methods</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notch_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flat_parms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor args are explained in the class description above.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.create_intervals_data">
<span class="sig-name descname"><span class="pre">create_intervals_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.create_intervals_data" title="Permalink to this definition"></a></dt>
<dd><p>The function updates and returns intervals_df - a DataFrame
with the EEG data based on timestamps from <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a>.
Prints warning if no clean segments were found.</p>
<p>The DataFrame has the following columns:</p>
<ul class="simple">
<li><p>scan_id - ID of the EEG recording.</p></li>
<li><p>interval_start - timestamp in datapoints of the segment start.</p></li>
<li><p>interval_length - length in datapoints of the segment.</p></li>
<li><p>data - numpy array of the EEG amplitude data, with shape
(&lt;n_target_channels&gt;, length in seconds x sampling frequency).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>self.interval_df</strong> (<em>DataFrame</em>) – a dataframe with extracted segments</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Saving this dataframe into a CSV file will truncate the content
of the ‘data’ column and convert it to a string, so the data will be lost.
Recommend to save the data into .npy file separately and keep the .csv
for later matching with labels.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.extract_good">
<span class="sig-name descname"><span class="pre">extract_good</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.extract_good" title="Permalink to this definition"></a></dt>
<dd><p>This function calls the functions above to identify “bad” intervals and
updates the attribute <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a> with timesptamps to extract</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_length</strong> (<em>float</em>) – length in seconds of the segments to be extracted
from this EEG recording; the value from <cite>self.conf_dict</cite> will be used
if not specified</p></li>
<li><p><strong>target_segments</strong> (<em>int</em>) – a total number of the segments to extract
from this EEG recording; the value from <cite>self.conf_dict</cite> will be used
if not specified</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.flat_intervals">
<span class="sig-name descname"><span class="pre">flat_intervals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.flat_intervals" title="Permalink to this definition"></a></dt>
<dd><p>Identify beginning and end times of flat signal</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – List of <em>[start, end]</em> time values
for each interval</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.hyperventilation">
<span class="sig-name descname"><span class="pre">hyperventilation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.hyperventilation" title="Permalink to this definition"></a></dt>
<dd><p>Identify beginning and end of hyperventilation from EEG data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – [[start1, end1],…,[startN, endN]] or []: a list of start and end times
of hyperventilation intervals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.photic_stimulation">
<span class="sig-name descname"><span class="pre">photic_stimulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.photic_stimulation" title="Permalink to this definition"></a></dt>
<dd><p>Identify beginning and end times of photic stimulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – [[start1, end1],…,[startN, endN]] or []: a list of start and end times
of photic stimulation series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.save_edf">
<span class="sig-name descname"><span class="pre">save_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.save_edf" title="Permalink to this definition"></a></dt>
<dd><p>The function writes out new EDF file(s) based on <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a> timestamps.
It saves each segment into a separate EDF file, with suffixes “[scan_id]_1”,
“[scan_id]_2”, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>folder</strong> (<em>str</em>) – where to save the new EDF files</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – main name for the output files (suffix will be added for more than 1 files)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>success</strong> (<em>bool</em>) – <cite>True</cite> if clean interval(s) exist and are saved, <cite>False</cite> otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.assign_known_channel_types">
<span class="sig-name descname"><span class="pre">assign_known_channel_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.assign_known_channel_types" title="Permalink to this definition"></a></dt>
<dd><p>Set channel types based on type information available in <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the Raw object; channel data does not need to be preloaded</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
Default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with known channel types (see below). If None,
this dictionary will be created</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with keys representing channel types and values as
lists of corresponding channel names. If supplied as an argument,
its keys (if present) will be updated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.load_edf_data">
<span class="sig-name descname"><span class="pre">load_edf_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_csv_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.load_edf_data" title="Permalink to this definition"></a></dt>
<dd><p>The function loads multiple EDF files and returns data
with lables suitable for analysis and machine learning models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_folder</strong> (<em>str</em>) – folder with EDF files</p></li>
<li><p><strong>labels_csv_path</strong> (<em>str</em>) – CSV dile containing scan_ids and label (age)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>X</strong> (<em>NumPy array</em>) – EEG amplitudes from EDF files, having
shape of ([n_samples], 20, [length in seconds] x [sampling frequency])</p></li>
<li><p><strong>labels</strong> (<em>NumPy array</em>) – age labels corresponding to each sample from X</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function fits a very specific CSV file ‘age_ScanID.csv’,
so it’s looking for columns ‘ScanID’ for scan ids, ‘AgeYears’ for age labels.
You might want to adjust column names in your own file or change this function.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.read_edf">
<span class="sig-name descname"><span class="pre">read_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preload</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.read_edf" title="Permalink to this definition"></a></dt>
<dd><p>Reads an EDF file with the MNE package, creates the Raw EDF object.
Excludes some channels to keep only target ones plus possibly some additional
non-eeg channels.</p>
<p>All target channels are set to be ‘eeg’ type - that is, EEG sensor type
Channels with names matching those in EOG, ECG channels lists are set to be
‘eog’, ‘ecg’ types respectively. All other included channels are set to be of ‘misc’ type.</p>
<p>Raises an exception in case the input recording  doesn’t have all
mandatory channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> (<em>str</em>) – EDF file pathname</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
Default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>target_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of mandatory channels to read from the EDF
file. If supplied, <em>target_channels</em> list will be used instead of the one provided
by either of the <em>conf_…</em> arguments.</p></li>
<li><p><strong>exclude_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of channels to be excluded when reading
the EDF file. If supplied, <em>exlclude_channels</em> list will be used instead of the one provided
by either of <em>conf_…</em> arguments.</p></li>
<li><p><strong>preload</strong> (<em>Bool</em>) – (default True) flag to read all the data into memory</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Raw</strong> (<em>mne.Raw</em>) – raw EDF object</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If both <em>conf_json</em> and <em>conf_dict</em> are omitted in the function call, the default settings will be read from</p>
<p><a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> which should be present in the same folder as the <em>edf_preprocessing.py</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.slice_edfs">
<span class="sig-name descname"><span class="pre">slice_edfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_folder</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_scan_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'good'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.slice_edfs" title="Permalink to this definition"></a></dt>
<dd><p>The function runs a pipeline for preprocessing and extracting
clean segment(s) of requested length from multiple EDF files.
It takes in a list of EDF file names and preprocessing parameters,
looks up for the files in source folder, and performs preprocessing
and extraction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_folder</strong> (<em>str</em>) – a pathname to the folder with EDF files</p></li>
<li><p><strong>target_folder</strong> (<em>str</em>) – a pathname to the output folder where the extracted segments
will be saved in EDF format</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters.
The default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant.</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>source_scan_ids</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>None</em>) – a list of short EDF file names without .edf
extention to preprocess. If None, all .edf files in the source directory will
be preprocessed, up to a limit set by the <em>nfiles</em> argument</p></li>
<li><p><strong>target_frequency</strong> (<em>num</em><em> or </em><em>None</em>) – the final EEG frequency after resampling; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>lfreq</strong> (<em>float</em><em> or </em><em>None</em>) – the lower frequency boundary of the EEG signal in Hz; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>hfreq</strong> (<em>float</em><em> or </em><em>None</em>) – the higher frequency boundary of the EEG signal in Hz; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>extract</strong> (<em>str</em>) – one of ‘good’ (default), ‘HV’ or ‘PS’. In the first case good segments (no artifacts
stimuli, etc. present). In the 2nd case hyperventilation intervals will be extracted.
In the 3d case photic stimulation intervals will be extracted.</p></li>
<li><p><strong>target_length</strong> (<em>float</em>) – the length of each of the extracted segments in seconds; the value
from <cite>conf_json</cite> or <cite>conf_dict</cite> will be used if not specified. Only applies when
<cite>extract = ‘good’</cite>. In HV case the length will be equal to that of 1st HV interval.</p></li>
<li><p><strong>target_segments</strong> (<em>int</em>) – the maximum number of segments to extract from each EDF file; the value
from <cite>conf_json</cite> or <cite>conf_dict</cite> will be used if not specified. Only applies when
<cite>extract = ‘good’</cite>. In HV case only the 1st HV interval will be extracted.</p></li>
<li><p><strong>nfiles</strong> (<em>int</em><em> or </em><em>None</em>) – the max number of the source files to preprocess; (default = None = no limit)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-individual_func">
<span id="individual-func-py"></span><h2>individual_func.py<a class="headerlink" href="#module-individual_func" title="Permalink to this heading"></a></h2>
<p><strong>*Functions related to EDF files manipulations.*</strong></p>
<p>Created on Wed Dec  5 12:56:31 2018
&#64;author: skjerns</p>
<p>Gist to save a mne.io.Raw object to an EDF file using pyEDFlib
(<a class="reference external" href="https://github.com/holgern/pyedflib">https://github.com/holgern/pyedflib</a>)</p>
<p>Disclaimer:</p>
<ul class="simple">
<li><p>Saving your data this way will result in slight
loss of precision (magnitude +-1e-09).</p></li>
<li><p>It is assumed that the data is presented in Volt (V),
it will be internally converted to microvolt</p></li>
<li><p>BDF or EDF+ is selected based on the filename extension</p></li>
<li><p>Annotations are lost in the process.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="individual_func.prefilter_string">
<span class="sig-name descname"><span class="pre">prefilter_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.prefilter_string" title="Permalink to this definition"></a></dt>
<dd><p>Generate channel prefilter string like “HP:0.5Hz LP:55Hz N:60Hz”</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that <cite>info[“lowpass”]</cite> and <cite>info[“high pass”]</cite> values
describe a bandpass filter applied to EEG channels only; notch
filter info applies to EEG channels plus EOG, ECG channels;
both bandpass and notch filters info is ignored for other channel types.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>info</strong> (<em>MNE info</em>) – as is</p></li>
<li><p><strong>ch_num</strong> (<em>int</em>) – 0-based channel number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>s</strong> (<em>string</em>) – the prefilter string described above (possibly empty)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.read_notch_info">
<span class="sig-name descname"><span class="pre">read_notch_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.read_notch_info" title="Permalink to this definition"></a></dt>
<dd><p>Read notch frequency (if any) from the raw.info[“description”] string.
It is assumed that if notch filtering was performed, its frequency was
saved with the raw.info object using the <a class="reference internal" href="#individual_func.save_notch_info" title="individual_func.save_notch_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">save_notch_info</span></code></a> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>info</strong> (<em>MNE info</em>) – as is</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>notch_freq</strong> (<em>float or None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.safe_crop">
<span class="sig-name descname"><span class="pre">safe_crop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.safe_crop" title="Permalink to this definition"></a></dt>
<dd><p>A wrapper for raw.crop() method which properly adjusts timings of
annotations.</p>
<p>In MNE v1.3 at least for EDF recordings we are dealing with the cropped raw object
annotations still have onsets relative to the start of the original (uncropped) data.
Such behavior might be by design - see extremely confusing explanations
about the <a class="reference external" href="https://mne.tools/stable/generated/mne.Annotations.html#mne.Annotations">Annotations</a>
class.</p>
<p>This function checks if annotation timings were corrected after cropping,
and applies correction if they were not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>MNE Raw</em>) – an object to be cropped</p></li>
<li><p><strong>args</strong> (<em>other</em>) – arguments to be passed to the
<a class="reference external" href="https://mne.tools/stable/generated/mne.io.Raw.html#mne.io.Raw.crop">Raw.crop()</a> method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>raw</strong> (<em>MNE Raw</em>) – the modified in place cropped raw object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.save_notch_info">
<span class="sig-name descname"><span class="pre">save_notch_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notch_freq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.save_notch_info" title="Permalink to this definition"></a></dt>
<dd><p>Save notch filter frequency to <cite>raw.info[“description”]</cite> string.
This may be necessary because MNE does not save the notching info neither with
the Raw object nor in the FIF file. This is implemented by appending to the
value of the “description” key the following string:</p>
<p><cite>“Notch filter: {} Hz”.format(notch_freq)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>info</strong> (<em>MNE info</em>) – as is</p></li>
<li><p><strong>notch_freq</strong> (<em>float</em><em> or </em><em>int</em>) – the notching frequency, Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None; info[“description”] key is updated in place</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.select_chans">
<span class="sig-name descname"><span class="pre">select_chans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ch_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">belong</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.select_chans" title="Permalink to this definition"></a></dt>
<dd><p>From the input channel list <cite>ch_list</cite> select channels that belong to the <cite>target list</cite>.
The string comparison is performed case insensitive, but original case is
preserved in the returned list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ch_list</strong> (<em>list</em><em> of </em><em>str</em>) – input channel list</p></li>
<li><p><strong>target_list</strong> (<em>list</em><em> of </em><em>str</em>) – a target channel list</p></li>
<li><p><strong>belong</strong> (<em>bool</em>) – <cite>True</cite> (default) if request is to find channels that belong to the target list,
<cite>False</cite> if one wants channels that do NOT belong to the target list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>selected_channels, flags</strong></p></li>
<li><p><strong>selected_channels</strong> (<em>list of str</em>) – a list of channels from the input list
that belong to the <cite>target list</cite></p></li>
<li><p><strong>flags</strong> (<em>list of bool</em>) – list of flags indicating if elements of <cite>ch_list</cite>
belong / not belong to the <cite>target_list</cite>; <cite>len(flags)</cite> equals to <cite>len(ch_list)</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.set_channel_types">
<span class="sig-name descname"><span class="pre">set_channel_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.set_channel_types" title="Permalink to this definition"></a></dt>
<dd><p>Set data channel types based on their names.</p>
<p>If a channel name belongs to the <cite>type_list</cite> (case-insensitive),
then corresponding channel’s type will be set to the <cite>type_name</cite>.
The raw object will also be updated. As a result,
<cite>ch_groups[type_name]</cite> will contain all channels belonging to
the type including those that were previously marked as such in the
<cite>self.raw`object</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the Raw object; channel data does not need to be preloaded</p></li>
<li><p><strong>type_name</strong> (<em>str</em>) – the channel type, such as ‘eog’, ‘ecg’, ‘eeg’, etc.</p></li>
<li><p><strong>type_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of known channel names that belong to this type.</p></li>
<li><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with known channel types (see below). If None,
this dictionary will be created</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with keys corresponding to channel types and
values being lists of corresponding channel names. If supplied as an argument,
its key equal to <cite>type_name</cite> will be updated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.write_mne_edf">
<span class="sig-name descname"><span class="pre">write_mne_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mne_raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">picks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.write_mne_edf" title="Permalink to this definition"></a></dt>
<dd><p>Saves the raw content of a <cite>MNE.io.Raw</cite> and its subclasses to
a file using the EDF+/BDF filetype
pyEDFlib is used to save the raw contents of the RawArray to disk</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mne_raw</strong> (<em>mne.io.Raw</em>) – An object with super class <cite>mne.io.Raw</cite> that contains the data
to save</p></li>
<li><p><strong>fname</strong> (<em>string</em>) – File name of the new dataset. This has to be a new filename
unless data have been preloaded. Filenames should end with .edf</p></li>
<li><p><strong>picks</strong> (<em>array-like</em><em> of </em><em>int</em><em> or </em><em>None</em>) – Indices of channels to include. If <cite>None</cite> all channels are kept.</p></li>
<li><p><strong>tmin</strong> (<em>float</em><em> | </em><em>None</em>) – Time in seconds of first sample to save. If <cite>None</cite> first sample
is used.</p></li>
<li><p><strong>tmax</strong> (<em>float</em><em> | </em><em>None</em>) – Time in seconds of last sample to save. If <cite>None</cite> last sample
is used.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em>) – If <cite>True</cite>, the destination file (if it exists) will be overwritten.
If <cite>False</cite> (default), an error will be raised if the file exists.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-run_pyprep_ica">
<span id="run-pyprep-ica-py"></span><h2>run_pyprep_ica.py<a class="headerlink" href="#module-run_pyprep_ica" title="Permalink to this heading"></a></h2>
<p><strong>A top level script to perform the PyPREP and ICA artifact removal step.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="run_pyprep_ica.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#run_pyprep_ica.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output</p></li>
<li><p><strong>data folders, and a flag indicating whether host is on CC cluster</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-do_pyprep">
<span id="do-pyprep-py"></span><h2>do_pyprep.py<a class="headerlink" href="#module-do_pyprep" title="Permalink to this heading"></a></h2>
<p><strong>Classes and functions used in the  PyPREP/ICA step.</strong></p>
<dl class="py data">
<dt class="sig sig-object py" id="do_pyprep.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'pyprep_ica_conf.json'</span></em><a class="headerlink" href="#do_pyprep.JSON_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Default name (without a path) for the JSON file with parameter settings for
the PYPREP procedure and ICA artifact removal. This file is expected
to reside in the same folder as the <em>do_pyprep.py</em> source file.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="do_pyprep.Pipeline">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_pyprep.Pipeline" title="Permalink to this definition"></a></dt>
<dd><p>The class’ aim is preprocessing clean extracted segments of clinical
EEG recordings (in EDF format) and make them a suitable input for later analysis
and ML applications.</p>
<p>The class instantiates a preprocessing object which
carries a Raw EDF file through the following operations:</p>
<p>1. Removes power lines, re-references the channels and identifies bad channels
as per the PREP pipeline.</p>
<p>2. Performs ICA on the given EEG segment for both EOG and ECG channels.
Then the object returns a pre-processed EEG data in raw format.</p>
<p><strong>Attributes</strong></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.conf_dict">
<span class="sig-name descname"><span class="pre">conf_dict</span></span><a class="headerlink" href="#do_pyprep.Pipeline.conf_dict" title="Permalink to this definition"></a></dt>
<dd><p>a dictionary containing all settings; typically reflects
contents of the JSON file <a class="reference internal" href="#do_pyprep.JSON_CONFIG_FILE" title="do_pyprep.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.ch_groups">
<span class="sig-name descname"><span class="pre">ch_groups</span></span><a class="headerlink" href="#do_pyprep.Pipeline.ch_groups" title="Permalink to this definition"></a></dt>
<dd><p>a dictionary containing lists of channels of certain types</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#do_pyprep.Pipeline.raw" title="Permalink to this definition"></a></dt>
<dd><p>the MNE Raw EDF object</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mne.Raw</p>
</dd>
</dl>
</dd></dl>

<p><strong>Methods</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.__init__" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> (<em>str</em>) – EDF file pathname</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters.
The default configuration file name is given by <a class="reference internal" href="#do_pyprep.JSON_CONFIG_FILE" title="do_pyprep.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant.</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters.
If both <cite>conf_json</cite> and <cite>conf_dict</cite> are given, the latter is used.</p></li>
<li><p><strong>view_plots</strong> (<em>bool</em>) – If <cite>True</cite>, various interactive data plots will be shown.
Set it to False (default) if processing multiple files.</p></li>
<li><p><strong>ts_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the original EDF
time series.</p></li>
<li><p><strong>psd_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the original EDF
PSD.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.applyPipeline">
<span class="sig-name descname"><span class="pre">applyPipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">applyICA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_postprep_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_postprep_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_postica_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.applyPipeline" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Applies the pipeline (resampling, filtering, applying PREP, performing ICA)</dt><dd><p>on the given EEG segment</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>applyICA</strong> (<em>bool</em>) – flag to remove EOG, ECG - related ICs from the signals</p></li>
<li><p><strong>view_plots</strong> (<em>bool</em>) – flag to show tons of plots; execution will be paused
each time a plot is shown</p></li>
<li><p><strong>ts_postprep_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
time series after PREP is done.</p></li>
<li><p><strong>psd_postprep_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
PSD after PREP is done.</p></li>
<li><p><strong>psd_postica_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
PSD after PREP and ICA are both done.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.filter_group">
<span class="sig-name descname"><span class="pre">filter_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'eog'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.filter_group" title="Permalink to this definition"></a></dt>
<dd><p>Filters specified channel group to be used as templates for ICA artifact removal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>what</strong> (<em>str</em>) – currently either “eog” or “ecg” - the channel group name</p></li>
<li><p><strong>view_plots</strong> (<em>bool</em>) – flag to view plots</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.getRaw">
<span class="sig-name descname"><span class="pre">getRaw</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_pyprep.Pipeline.getRaw" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Raw EDF object</strong> (<em>preprocessed</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.ica">
<span class="sig-name descname"><span class="pre">ica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.ica" title="Permalink to this definition"></a></dt>
<dd><p>Performs ICA on the given EEG segment for both EOG and ECG channels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>view_plots</strong> – flag to show interactive plots</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.prep">
<span class="sig-name descname"><span class="pre">prep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.prep" title="Permalink to this definition"></a></dt>
<dd><p>Applies the PREP pipeline to the EEG segment to mark the bad channels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>view_plots</strong> – boolean value to denote if we want to view plots</p></li>
<li><p><strong>ts_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the processed EDF
time series.</p></li>
<li><p><strong>psd_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the processed EDF
PSD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.showplot">
<span class="sig-name descname"><span class="pre">showplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">picks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savefile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.showplot" title="Permalink to this definition"></a></dt>
<dd><p>Plot the time courses and / or power spectrum  of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>title</strong> (<em>str</em>) – the plot title</p></li>
<li><p><strong>time_series</strong> (<em>bool</em>) – whether time series should be plotted</p></li>
<li><p><strong>psd</strong> (<em>bool</em>) – whether power spectrum should be plotted</p></li>
<li><p><strong>picks</strong> (<em>str</em><em> or </em><em>lst</em>) – channels to plot; if <cite>None</cite> (default) -
all channels will be plotted</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – flag to show the plot interactively (execution
is paused)</p></li>
<li><p><strong>savefile</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, the name of the file to save
the plot to.</p></li>
<li><p><strong>dpi</strong> (<em>int</em><em> or </em><em>None</em>) – if not None, the DPI setting for the saved plot.
Ignored if savefile is None.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only one of <cite>time_series</cite> or <cite>psd</cite> should be <cite>True</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-extract_hv_intervals">
<span id="extract-hv-intervals-py"></span><h2>extract_hv_intervals.py<a class="headerlink" href="#module-extract_hv_intervals" title="Permalink to this heading"></a></h2>
<p><strong>A top level script to perform filtering and extraction of hyperventilation (HV)
intervals.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="extract_hv_intervals.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#extract_hv_intervals.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output
data folders, and a flag indicating whether host is on CC cluster</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-extract_ps_intervals">
<span id="extract-ps-intervals-py"></span><h2>extract_ps_intervals.py<a class="headerlink" href="#module-extract_ps_intervals" title="Permalink to this heading"></a></h2>
<p><strong>A top level script to perform filtering and extraction of photic stimulation (PS)
intervals.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="extract_ps_intervals.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#extract_ps_intervals.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output
data folders, and a flag indicating whether host is on CC cluster</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-create_ps_events">
<span id="create-ps-events-py"></span><h2>create_ps_events.py<a class="headerlink" href="#module-create_ps_events" title="Permalink to this heading"></a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="create_ps_events.PREPROC_CONF_FILE">
<span class="sig-name descname"><span class="pre">PREPROC_CONF_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'preproc_conf.json'</span></em><a class="headerlink" href="#create_ps_events.PREPROC_CONF_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with parameter settings for
the preprocessing step, which contains keywords that identify
photic stimulation intervals. This file is expected to reside in the same
folder as this script.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="create_ps_events.create_ps_events">
<span class="sig-name descname"><span class="pre">create_ps_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#create_ps_events.create_ps_events" title="Permalink to this definition"></a></dt>
<dd><p>Using <cite>raw.annotations</cite>, extract all events related to photic
stimulation (PS) and create corresponding <cite>events</cite> array in MNE
Python format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>MNE Raw</em>) – the <cite>Raw</cite> object of the EEG record</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbose level; one of ‘DEBUG’, ‘INFO’,
ERROR’, ‘CRITICAL’, or ‘WARNING’ (default)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>events</strong> (<em>ndarray</em>) – shape(nevents, 3) The MNE Python events array
(<a class="reference external" href="https://mne.tools/1.4/glossary.html#term-events">https://mne.tools/1.4/glossary.html#term-events</a>)</p></li>
<li><p><strong>event_id</strong> (<em>dict</em>) – The <cite>event_id</cite> variable that can be passed
to the <cite>Epochs</cite> object constructor (example: dict(auditory=1, visual=3)).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="create_ps_events.get_ps_frq">
<span class="sig-name descname"><span class="pre">get_ps_frq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">desc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#create_ps_events.get_ps_frq" title="Permalink to this definition"></a></dt>
<dd><p>Read the PS frequency value from the PS event description
and return it as an integer value. If not found, return
<cite>None</cite>.</p>
</dd></dl>

</section>
<section id="module-run_src_reconstr">
<span id="run-src-reconstr-py"></span><h2>run_src_reconstr.py<a class="headerlink" href="#module-run_src_reconstr" title="Permalink to this heading"></a></h2>
<p><strong>A top level script for running the source reconstruction step.</strong></p>
<dl class="py data">
<dt class="sig sig-object py" id="run_src_reconstr.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'src_reconstr_conf.json'</span></em><a class="headerlink" href="#run_src_reconstr.JSON_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Default name (without a path) for the JSON file with parameter settings for
the source reconstruction step. This file is expected
to reside in the same folder as this file.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_src_reconstr.PYPREP_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">PYPREP_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'pyprep_ica_conf.json'</span></em><a class="headerlink" href="#run_src_reconstr.PYPREP_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with parameter settings for
the PYPREP/ICA step. This file is expected to reside in the same folder
as this script.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_src_reconstr.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#run_src_reconstr.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_root</strong> (<em>str</em>) – path to the root input folder</p></li>
<li><p><strong>out_root</strong> (<em>str</em>) – path to the root output folder</p></li>
<li><p><strong>fs_dir</strong> (<em>str</em>) – path to the folder with the template subject ‘fsaverage’ data</p></li>
<li><p><strong>cluster_job</strong> (<em>bool</em>) – a flag indicating whether the host is on CC cluster</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-add_virtual_channels">
<span id="add-virtual-channels-py"></span><h2>add_virtual_channels.py<a class="headerlink" href="#module-add_virtual_channels" title="Permalink to this heading"></a></h2>
<p><strong>A utility function to add virtual (source-reconstructed) channels to the raw dataset. This may be useful
for viewing/processing the EEG data using standard MNE Python routines.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="add_virtual_channels.add_virtual_channels">
<span class="sig-name descname"><span class="pre">add_virtual_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vc_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#add_virtual_channels.add_virtual_channels" title="Permalink to this definition"></a></dt>
<dd><p>Add virtual channels with data to an existing physical dataset.</p>
<p>The virtual channels will have type matching the type of the physical
sensors, their spatial locations will be set as specified, and their
orientations will be set arbitrarily (and therefore should never be used).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the raw object with physical sensor channels.</p></li>
<li><p><strong>vc_names</strong> (<em>list</em><em> of </em><em>str</em>) – a list of <cite>n_vc</cite> virtual channel names.</p></li>
<li><p><strong>vc_pos</strong> (<em>ndarray</em>) – <cite>n_vc x 3</cite>; virtual sensors positions in <strong>MNE HEAD</strong>
coordinate system, m</p></li>
<li><p><strong>vc_data</strong> (<em>ndarray</em>) – <cite>n_vc x n_times</cite>; virtual channels time courses</p></li>
<li><p><strong>verbose</strong> (<em>str</em>) – the verbose mode, or None for using MNE default mode.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>raw</strong> (<em>mne.Raw</em>) – the modified in place instance of the input Raw object</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-do_src_reconstr">
<span id="do-src-reconstr-py"></span><h2>do_src_reconstr.py<a class="headerlink" href="#module-do_src_reconstr" title="Permalink to this heading"></a></h2>
<p><strong>Functions used by the source reconstruction step.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.beam_extract_label_time_course">
<span class="sig-name descname"><span class="pre">beam_extract_label_time_course</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sensor_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca_flip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.beam_extract_label_time_course" title="Permalink to this definition"></a></dt>
<dd><p>Compute spatial filter weights and time courses for ROIs (labels) using beamformer
inverse solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sensor_data</strong> (<em>ndarray</em>) – nchan x ntimes; EEG channels time courses</p></li>
<li><p><strong>cov</strong> (<em>ndarray</em>) – nchan x nchan; the sensor time courses covariance matrix</p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of mne.Label objects for the ROIs</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc; beamformer weights for the whole (global) source space</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – a method of constructing a single time course for the ROI; see description
of <cite>mne.extract_label_time_course()</cite> function</p></li>
<li><p><strong>verbose</strong> (<em>str</em>) – verbose mode</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes; ROI time courses</p></li>
<li><p><strong>label_wts</strong> (<em>ndarray</em>) – nchan x nlabels; spatial filter weights for each label</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_beamformer_stc">
<span class="sig-name descname"><span class="pre">compute_beamformer_stc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_beamformer_stc" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct source time courses using single source minimum variance
beamformer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the raw data containing only good sensor channels</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>return_stc</strong> (<em>bool</em>) – flag to compute all source time courses and to return
corresponding SourceEstimate object</p></li>
<li><p><strong>beam_type</strong> (<em>str</em>) – beamformer type: one of <cite>‘pz’</cite> (pseudo-Z) or <cite>‘ai’</cite> (activity
index) scalar beamformer can be calculated.</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em>) – tolerance (relative accuracy) in finding the noise_cov trace.</p></li>
<li><p><strong>rcond</strong> (<em>float &gt; 0</em>) – condition for determining rank of the covariance matrix:
singular values less than <cite>max(sing val) * rcond</cite> will be considered zero.</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbose mode (see MNE docs for details)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>stc</strong> (<em>mne.SourceEstimate or None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space, provided return_stc flag is True; None otherwise</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray</em>) – nchan x nchan, sensor covariance matrix adjusted to a nearest
positive definite matrix</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc array of beamformer weights</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – 3 x nsrc array of source orientations</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>, where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_roi_time_courses">
<span class="sig-name descname"><span class="pre">compute_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inv_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca_flip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_roi_time_courses" title="Permalink to this definition"></a></dt>
<dd><p>Compute time courses for ROIs (labels).</p>
<p>If <cite>inv_method</cite> is ‘beam’ and <cite>mode</cite> is <cite>pca_flip</cite> - <cite>beam_extract_label_time_course()</cite>
will be used; otherwise a MNE function  mne.extract_label_time_course() will be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inv_method</strong> (<em>str</em>) – inverse method used to create the <cite>stc</cite></p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of mne.Label objects for the ROIs</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – a method of constructing a single time course for ROI - see description
of <a href="#id1"><span class="problematic" id="id2">`</span></a>mne.extract_label_time_course() function.</p></li>
<li><p><strong>stc</strong> (<em>mne.SourceEstimate</em><em> or </em><em>None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space; only needed for non-beamformer reconstructions</p></li>
<li><p><strong>sensor_data</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x ntimes; EEG channels time courses. Must be
specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>cov</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x nchan; the sensor time courses covariance matrix. Must be
specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>W</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x nsrc; beamformer weights for the whole (global) source space.
Must be specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>verbose</strong> (<em>str</em>) – verbose mode</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes; ROI time courses</p></li>
<li><p><strong>label_wts</strong> (<em>ndarray or None</em>) – nchan x nlabels; spatial filter weights for each label for
beamformer reconstructions, None for other (min norm) reconstructions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_source_timecourses">
<span class="sig-name descname"><span class="pre">compute_source_timecourses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'beam'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_source_timecourses" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct source time courses for all sources in the source space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the raw data containing only good sensor channels</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>method</strong> (<em>str</em>) – source reconstruction method; currently only beamformer
(method = ‘beam’) is implemented</p></li>
<li><p><strong>return_stc</strong> (<em>bool</em>) – flag to compute all source time courses and to return
corresponding SourceEstimate object</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – dictionary with method-specific arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>stc</strong> (<em>mne.SourceEstimate or None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space, if <cite>return_stc = True</cite>, or None otherwise.</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray or None</em>) – nchan x nchan; if <cite>method = ‘beam’</cite>: sensor covariance matrix
adjusted to a nearest positive definite matrix; None otherwise</p></li>
<li><p><strong>W</strong> (<em>ndarray or None</em>) – nchan x nsrc; if <cite>method = ‘beam’</cite>:  array of beamformer weights;
None othewise</p></li>
<li><p><strong>U</strong> (<em>ndarray or None</em>) – 3 x nsrc; if <cite>method = ‘beam’</cite>: array of source orientations;
None otherwise</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>, where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.construct_noise_and_inv_cov">
<span class="sig-name descname"><span class="pre">construct_noise_and_inv_cov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_cov</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.construct_noise_and_inv_cov" title="Permalink to this definition"></a></dt>
<dd><p>Based on the forward solutions, construct sensor-level noise covariance
matrix assuming white, randomly oriented uncorrelated sources. Also calculate
pseudo-inverse of the data cov and SNR.</p>
<p>The basic expression for noise covariance is:</p>
<p><cite>cov0 = const * SUM(i=1 to Nsrc){Hx Hx’ + Hy Hy’ + Hz Hz’}</cite></p>
<p>where <cite>Hx,y,z(i)</cite> are forward solutions for i-th source with corresponding
orientations, and <cite>const</cite> is defined so as data_cov - noise_cov is non-negative.</p>
<p>For degenerate data_cov the noise_cov should also be degenerate with a
range subspace coinciding with the range of the data_cov. In this case the
above expression should be replaced with</p>
<p><cite>cov = P * cov0 * P</cite></p>
<p>where <cite>P = data_cov * pinv(data_cov)</cite> is a projector on the <cite>range(data_cov)</cite>.</p>
<p>The trace of the noise_cov is maximized while keeping the difference
<cite>data_cov - noise_cov</cite> non-negative. The tol parameter defines how close to
the upper boundary one should get.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>Forward</em>) – mne Python forward solutions class</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray</em>) – nchan x nchan data covariance matrix</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em>) – tolerance in finding the noise_cov trace.</p></li>
<li><p><strong>rcond</strong> (<em>float &gt; 0</em>) – singular values less than max(sing val) * rcond will
be dropped</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cov</strong> (<em>ndarray</em>) – (nchan x nchan) noise cov matrix, such that the difference
data_cov - noise_cov is non-negatively defined</p></li>
<li><p><strong>inv_cov</strong> (<em>ndarray</em>) – (nchan x nchan) (pseudo-) inverse of the data cov</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – rank of the data covariance</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – psedo-Z = SNR + 1 of the data; <cite>pz=tr(data_cov)/tr(noise_cov)</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.encode_vertex_list">
<span class="sig-name descname"><span class="pre">encode_vertex_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_left</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.encode_vertex_list" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Make left hemi vertex numbers negative or equal to _LEFT_HEMI_ZERO</dt><dd><p>as appropriate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertno</strong> (<em>ndarray</em>) – 1D array of vertex numbers &gt;=0</p></li>
<li><p><strong>is_left</strong> (<em>bool</em>) – <cite>True</cite> for left hemisphere, <cite>False</cite> for right hemisphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vtx</strong> (<em>ndarray</em>) – new vertex list; there are no changes for right hemi vertices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.fwd_file_name">
<span class="sig-name descname"><span class="pre">fwd_file_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scan_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.fwd_file_name" title="Permalink to this definition"></a></dt>
<dd><p>Construct forward solution file name base on the source space used</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scan_id</strong> (<em>str</em>) – subject ID (=scan id)</p></li>
<li><p><strong>src_file</strong> (<em>str</em>) – standard template source space name in the form
fsaverage-….-src.fif</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fwd_name</strong> (<em>str</em>) – fwd solutions file name in the form
scan_id-….-fwd.fif</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_beam_weights">
<span class="sig-name descname"><span class="pre">get_beam_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_beam_weights" title="Permalink to this definition"></a></dt>
<dd><p>Get beamformer weights matrix for a set of forward solutions</p>
<p>For each source, calculate a scalar beamformer weight using a formula</p>
<p><cite>w = const * R^(-1) h; h = [Hx, Hy, Hz]*u</cite></p>
<p>where <cite>R</cite> is the data covariance matrix, <cite>h</cite> is a “scalar” lead field corresponding
to the source orientation <cite>u</cite>. The normalization constant is selected depending
on the <cite>units</cite> parameter setting:</p>
<p><cite>units = “source”: const = (h’ R^(-1) h)^(-1)</cite></p>
<p><cite>units = “pz”:     const = [h’ R^(-1) N R^(-1) h]^(-1/2)</cite></p>
<p>In the first case absolute current dipole amplitudes (A*m) will be reconstructed.
In the 2nd case source amplitudes will be normalized on projected noise, effectively
representing source-level signal to noise ratio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>ndarray</em>) – nchan x (3*n_src) array of FS for a set of n_src sources</p></li>
<li><p><strong>inv_cov</strong> (<em>ndarray</em>) – nchan x nchan (pseudo-)inverse of sesnor cov matrix</p></li>
<li><p><strong>noise_cov</strong> (<em>ndarray</em>) – nchan x nchan noise cov matrix</p></li>
<li><p><strong>units</strong> (<em>str</em>) – either “source” or “pz”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc array of beamformer weights</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – 3 x nsrc array of source orientations</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_coms">
<span class="sig-name descname"><span class="pre">get_label_coms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_coms" title="Permalink to this definition"></a></dt>
<dd><p>Calculate center-of-mass vertices for ROIs
assuming that all vertices in ROI have identical weights.</p>
<p>The ROIs are defined on the ‘fsaverage’ subject’s original
(that is - dense) cortical surface. So are the returned
COM vertex numbers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the labels were restricted to a source space using
a coarser surface than the original FreeSurfer surface, the
returned COMs will also be vertices of this coarser surface.
Still the vertex numbers themselves refer to the original
dense surface. Importantly, “restricted” labels may sometimes
have their <cite>vertices</cite> lists empty. In this case, <strong>an exception
will be thrown</strong>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<em>list</em><em> of </em><em>Label</em>) – list of MNE Label objects</p></li>
<li><p><strong>fs_dir</strong> (<em>str</em>) – pathname to the subject’s directory that contains
the ‘fsaverage’ subject</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>label_coms</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_fwd">
<span class="sig-name descname"><span class="pre">get_label_fwd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_fwd" title="Permalink to this definition"></a></dt>
<dd><p>Get a subset of forward solutions corresponding to specified Label (ROI)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>H</strong> (<em>ndarray</em>) – nchan x (3*n_label_src) array of the ROI forward solutions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_pca_weight">
<span class="sig-name descname"><span class="pre">get_label_pca_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_pca_weight" title="Permalink to this definition"></a></dt>
<dd><p>Return a spatial filter vector <cite>w_pca</cite> such that a single label
(ROI) time course can be found by the expression <cite>w_pca’*b(t)</cite>, where
<cite>b</cite> is a vector of sensor time courses.</p>
<p><em>Explanation</em>. Covariance matrix of all signals that belong to a label is
<cite>R_label = W_label’* R * W_label</cite>, where R is the global sensor covariance and
<cite>W_label = nchan x n_label_src</cite> are label weights.
Let <cite>U0 = n_label_src x 1</cite> be the largest normalized eigenvector of R_label.
Then label time course <cite>s(t)</cite> corresponding to ‘pca_flip’ mode is found as</p>
<p><cite>s(t) = sign * scale * U0’ * W_label’ * b(t)</cite>,</p>
<p>where</p>
<p><cite>scale = sqrt[(trace(R_label)/E0)/n_label_src]</cite>,
<cite>sign = np.sign(U0’*flip)</cite></p>
<p>E0 is the largest eigenvalue of R_label and <cite>flip</cite> is a flip-vector returned by
MNE <cite>label_sign_flip()</cite> function. This scaling assigns the RMS of the powers
of all ROI sources to the returned single time course amplitude. Then it is
clear that the expression for <cite>w_pca</cite> is:</p>
<p><cite>w_pca = sign * scale * W_label * U0, w_pca = nchan x 1</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>ndarray</em>) – nchan x nchan, the global sensor data covariance matrix</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the forward solutions object for the whole source space</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc, weights matrix for the whole source space</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>w_pca</strong> (<em>ndarray</em>) – nchan x 1 weight vector for the ROI</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_src_idx">
<span class="sig-name descname"><span class="pre">get_label_src_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_src_idx" title="Permalink to this definition"></a></dt>
<dd><p>Get source indecies for a label (ROI)</p>
<p>Forward solution matrices H and weight matrices W have
columns (or triplets of columns) corresponding to sources
in the whole (left + right hemisphere) source space. At the
same time, the SourceSpaces object has separate source indexing
for each hemisphere, and so does the ROI (label). This function
returns a mapping from label vertices to columns of scalar H and
scalar W.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>idx</strong> (<em>1D array of ints</em>) – n_label_src-dimensional vector of indecies</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_wts">
<span class="sig-name descname"><span class="pre">get_label_wts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_wts" title="Permalink to this definition"></a></dt>
<dd><p>Get a subset of spatial filter weights corresponding to specified Label (ROI)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc, weights matrix for the whole source space</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W_label</strong> (<em>ndarray</em>) – nchan x (n_label_src) array of ROI weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_voxel_coords">
<span class="sig-name descname"><span class="pre">get_voxel_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_voxel_coords" title="Permalink to this definition"></a></dt>
<dd><p>Given vertex numbers, return voxel spatial coordinates for
a surface source space.</p>
<p>NOTE: the coordinate system is that of the source space; it may be
either MRI or head coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>mne.SourceSpaces</em>) – as is</p></li>
<li><p><strong>vertices</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rr</strong> (<em>ndarray</em>) – nvox x 3; coordinates of vertices. <cite>nvox = len(vertices)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.ltc_file_name">
<span class="sig-name descname"><span class="pre">ltc_file_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scan_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.ltc_file_name" title="Permalink to this definition"></a></dt>
<dd><p>Construct HDF5 file name for saved ROI time courses based on the source space used</p>
<p>Note that the names of ROIs themselves depend on the atlas (parcellation) used and
will be stored inside the generated HDF5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scan_id</strong> (<em>str</em>) – subject ID (=scan id)</p></li>
<li><p><strong>src_file</strong> (<em>str</em>) – standard template source space name in the form
fsaverage-….-src.fif</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fwd_name</strong> (<em>str</em>) – fwd solutions file name in the form
scan_id-….-ltc.hdf5</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.parse_vertex_list">
<span class="sig-name descname"><span class="pre">parse_vertex_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.parse_vertex_list" title="Permalink to this definition"></a></dt>
<dd><p>Parse a mixed list of vertices referring to left and right hemispheres.</p>
<p>The vertex list is in the format described in <cite>get_label_coms()</cite> is split
into separate lists for left and right hemispheres.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vertno</strong> (<em>ndarray</em>) – 1D signed integer array of vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>lh, rh, lh_idx, rh_idx</strong> (<em>tuple</em>) – 1D integer arrays <cite>lh, rh</cite> of left and right
hemisphere vertex numbers; 1D boolean arrays <cite>lh_idx, rh_idx</cite> indicating
locations of left and right vertices in the input list <cite>vertno</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.read_roi_time_courses">
<span class="sig-name descname"><span class="pre">read_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ltc_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.read_roi_time_courses" title="Permalink to this definition"></a></dt>
<dd><p>Read ROI (label) time courses and corresponding ROI names from .hdf5
file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ltc_file</strong> (<em>str</em>) – full pathname of the output .hdf5 file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes ROI time courses</p></li>
<li><p><strong>label_names</strong> (<em>ndarray of str</em>) – 1 x nlabels vector of ROI names</p></li>
<li><p><strong>vertno</strong> (<em>ndarray or None</em>) – 1D signed integer array of vertex numbers corresponding
to the ROI COMs. See <cite>parse_vertex_list()</cite> function regarding the vertex
numbers encoding rules.</p></li>
<li><p><strong>rr</strong> (<em>ndarray or None</em>) – nlabels x 3; coordinates of ROI reference locations
in head coordinates</p></li>
<li><p><strong>W</strong> (<em>ndarray or None</em>) – nchans x nlabels; spatial filter weights for each ROI.
Those can be used to reconstruct ROI time courses as <cite>W.T &#64; sensor_data</cite></p></li>
<li><p><strong>pz</strong> (<em>float or None</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>,
where <cite>N</cite> is the noise covariance</p></li>
<li><p><strong>ps_events</strong> (<em>ndarray</em>) – nevents x 3; PS events array in MNE Python ‘events’ format</p></li>
<li><p><strong>ps_id_dict</strong> (<em>dict</em>) – dictionary event_descr -&gt; event_id; see <cite>event_id</cite> parameter
description of the MNE <cite>Epochs</cite> object constructor</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.write_roi_time_courses">
<span class="sig-name descname"><span class="pre">write_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ltc_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_tcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ps_events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ps_id_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.write_roi_time_courses" title="Permalink to this definition"></a></dt>
<dd><p>Save ROI (label) time courses and related data in .hdf5
file.</p>
<p>The output file will contain at least two datasets with names ‘label_tcs’ and
‘label_names’. If provided, ROI centers of mass (COMs) vertex numbers
on the FreeSurface’s <cite>fsaverage</cite> cortex surface, ROI COMs in MRI coordinates,
ROI spatial filter weights and the EEG record overall pseudo-Z will also be saved.</p>
<p>If photic stimulation (PS) segments of the EEG records are processed, ‘events’ array
and ‘event_id’ dictionary corresponding to the PS stimulation events may be saved (if
passed as the parameters) in the datasets named ‘ps_events’, ‘ps_id_dict’ respectively.
Note that ps_id_dict is saved as a JSON string corresponding to the this dictionary
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltc_file</strong> (<em>str</em>) – full pathname of the output .hdf5 file</p></li>
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes ROI time courses</p></li>
<li><p><strong>label_names</strong> (<em>list</em><em> of </em><em>str</em>) – names of ROIs</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D signed integer array of vertex numbers corresponding
to the ROI COMs. See <cite>parse_vertex_list()</cite> function regarding the vertex
numbers encoding rules.</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nlabels x 3; coordinates of ROI reference locations
in head coordinates</p></li>
<li><p><strong>W</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchans x nlabels; spatial filter weights for each ROI.
Those can be used to reconstruct ROI time courses as <cite>W.T &#64; sensor_data</cite></p></li>
<li><p><strong>pz</strong> (<em>float</em><em> or </em><em>None</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>,
where <cite>N</cite> is the noise covariance.</p></li>
<li><p><strong>ps_events</strong> (<em>ndarray</em>) – nevents x 3; PS events array in MNE Python ‘events’ format</p></li>
<li><p><strong>ps_id_dict</strong> (<em>dict</em>) – dictionary event_descr -&gt; event_id; see <cite>event_id</cite> parameter
description of the MNE <cite>Epochs</cite> object constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-make_fsaverage_bem">
<span id="make-fsaverage-bem-py"></span><h2>make_fsaverage_bem.py<a class="headerlink" href="#module-make_fsaverage_bem" title="Permalink to this heading"></a></h2>
<p><strong>A function to create the BEM model, BEM solution and to generate a source space for the standard
`fsaverage` MRI template. May also be used as a standalone script.</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="make_fsaverage_bem.make_fsaverage_bem">
<span class="sig-name descname"><span class="pre">make_fsaverage_bem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subjects_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ico_bem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ico_src</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#make_fsaverage_bem.make_fsaverage_bem" title="Permalink to this definition"></a></dt>
<dd><p>Create BEM model, BEM solution and surface
source space for the template ‘fsaverage’ subject.</p>
<p>fsaverage’s BEMs and source space are normally supplied with the
fsaverage data for ico = 4 (5120) which produces rather dense source
space. This function can recreate these but the main purpose is to
generate lower resolution BEMs and source spaces (ico = 3) because for low
density EEGs the solutions supplied by have too high resolution.
Standard condactivities set (0.3, 00., 0.3) is used for the 3-layers EEG
forward modeling.</p>
<p>The calculated BEM / source spaces are saved to the ‘…/fsaverage/bem’ folder,
unless those already exist. In this case a warning is issued and calculation is
skipped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subjects_dir</strong> (<em>str</em>) – full path to the subjects’ folder containing fsaverage
subject</p></li>
<li><p><strong>ico_bem</strong> (<em>int</em>) – ico setting for BEM model: 3, 4, or 5</p></li>
<li><p><strong>ico_src</strong> (<em>int</em>) – ico setting for the source space: 3, 4, or 5</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbose mode to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nearest_pos_def">
<span id="nearest-pos-def-py"></span><h2>nearest_pos_def.py<a class="headerlink" href="#module-nearest_pos_def" title="Permalink to this heading"></a></h2>
<p><strong>A function to find a positive definite matrix which is most close to
a given matrix.</strong></p>
<dl class="simple">
<dt>This code by Ahmed Fasih was downloaded from</dt><dd><p><a class="reference external" href="https://gist.github.com/fasiha/fdb5cec2054e6f1c6ae35476045a0bbd">https://gist.github.com/fasiha/fdb5cec2054e6f1c6ae35476045a0bbd</a></p>
</dd>
</dl>
<p>on Oct 17, 2021</p>
<dl class="py function">
<dt class="sig sig-object py" id="nearest_pos_def.isPD">
<span class="sig-name descname"><span class="pre">isPD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nearest_pos_def.isPD" title="Permalink to this definition"></a></dt>
<dd><p>Returns true when input is positive-definite, via Cholesky</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nearest_pos_def.nearestPD">
<span class="sig-name descname"><span class="pre">nearestPD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nearest_pos_def.nearestPD" title="Permalink to this definition"></a></dt>
<dd><p>Find the nearest positive-definite matrix to input</p>
<p>A Python/Numpy port of John D’Errico’s <cite>nearestSPD</cite> MATLAB code [1], which
credits [2].</p>
<p>[1] <a class="reference external" href="https://www.mathworks.com/matlabcentral/fileexchange/42885-nearestspd">https://www.mathworks.com/matlabcentral/fileexchange/42885-nearestspd</a></p>
<p>[2] N.J. Higham, “Computing a nearest symmetric positive semidefinite
matrix” (1988): <a class="reference external" href="https://doi.org/10.1016/0024-3795(88)90223-6">https://doi.org/10.1016/0024-3795(88)90223-6</a></p>
</dd></dl>

</section>
<section id="module-run_welch">
<span id="run-welch-py"></span><h2>run_welch.py<a class="headerlink" href="#module-run_welch" title="Permalink to this heading"></a></h2>
<p><strong>A top level script to calculate PSDs for sensor and source reconstructed
data using the Welch method.</strong></p>
<dl class="py data">
<dt class="sig sig-object py" id="run_welch.PREPROC_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">PREPROC_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'preproc_conf.json'</span></em><a class="headerlink" href="#run_welch.PREPROC_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with preprocessing parameters
which was used to run filtering/segmentation step</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_welch.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_welch.get_data_folders" title="Permalink to this definition"></a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> (<em>dict</em>) – dictionary with input arguments read from the
<cite>INPUT_JSON_FILE</cite></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>data_root</strong> (<em>str</em>) – path to the root input folder</p></li>
<li><p><strong>out_root</strong> (<em>str</em>) – path to the root output folder</p></li>
<li><p><strong>cluster_job</strong> (<em>bool</em>) – a flag indicating whether the host is on CC cluster</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_welch.load_data">
<span class="sig-name descname"><span class="pre">load_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_welch.load_data" title="Permalink to this definition"></a></dt>
<dd><p>Read signal data from .fif or .hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>f</strong> (<em>str</em>) – full pathnname of the data file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>data</strong> (<em>nparray</em>) – <cite>nchan x ntimes</cite> signal data array</p></li>
<li><p><strong>chnames</strong> (<em>list of str</em>) – channel names</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_welch.plot_psd">
<span class="sig-name descname"><span class="pre">plot_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_welch.plot_psd" title="Permalink to this definition"></a></dt>
<dd><p>Plot saved sensor or ROI signals PSDs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – full pathname to the .hdf5 file created by
<cite>write_welch_psd()</cite></p></li>
<li><p><strong>ch_names</strong> (<em>list</em><em> of </em><em>str</em>) – list of channel or ROI names to plot</p></li>
<li><p><strong>title</strong> (<em>str</em><em> or </em><em>None</em>) – plot title</p></li>
<li><p><strong>xlim</strong> (<em>[</em><em>xmin</em><em>, </em><em>xmax</em><em>] or </em><em>None</em>) – X-axis limits</p></li>
<li><p><strong>ylim</strong> (<em>[</em><em>ymin</em><em>, </em><em>ymax</em><em>] or </em><em>None</em>) – Y-axis limits</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Nothing</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_welch.read_welch_psd">
<span class="sig-name descname"><span class="pre">read_welch_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_welch.read_welch_psd" title="Permalink to this definition"></a></dt>
<dd><p>Save PSDs of sensor or reconstructed ROI signals in .hdf5
file.</p>
<p>The input file is expected to contain three datasets: ‘ch_names’ with sensor channel or
ROI names, ‘freqs’ with frequency values in Hz, and ‘psd’ with PSD values in
units of U^2/Hz, where U is Volts for sensor channels PSD and U is A*m for
ROI signals PSDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – full pathname of the input .hdf5 file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ch_names</strong> (<em>list of str</em>) – names of channels or ROIs</p></li>
<li><p><strong>freqs</strong> (<em>ndarray</em>) – shape (nf,) frequency values, Hz</p></li>
<li><p><strong>psd</strong> (<em>ndarray</em>) – shape (nchans, nf) PSD values in U^2/Hz</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_welch.write_welch_psd">
<span class="sig-name descname"><span class="pre">write_welch_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_welch.write_welch_psd" title="Permalink to this definition"></a></dt>
<dd><p>Save PSDs of sensor or reconstructed ROI signals in .hdf5
file.</p>
<p>The output file will contain three datasets: ‘ch_names’ with sensor channel or
ROI names, ‘freqs’ with frequency values in Hz, and ‘psd’ with PSD values in
units of U^2/Hz, where U is Volts for sensor channels PSD. For ROI PSDs the unit U
depends on the setting of <cite>src_units</cite> parameter in <cite>src_reconstr_conf.json</cite> file
at the time of running the source reconstruction step. It is A*m when <cite>src_units</cite>
is set to ‘source’, or amplitude pseudo-Z when it is set to ‘pz’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – full pathname of the output .hdf5 file.</p></li>
<li><p><strong>ch_names</strong> (<em>list</em><em> of </em><em>str</em>) – names of channels or ROIs</p></li>
<li><p><strong>freqs</strong> (<em>ndarray</em>) – shape (nf,) frequency values, Hz</p></li>
<li><p><strong>psd</strong> (<em>ndarray</em>) – shape (nchans, nf) PSD values in U^2/Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-run_cwt">
<span id="run-cwt-py"></span><h2>run_cwt.py<a class="headerlink" href="#module-run_cwt" title="Permalink to this heading"></a></h2>
<p><strong>A top level script for calculating the  Continuous Wavelet Transforms (CWTs)
for sensor and source reconstructed data, and fitting the exponentiated Weibull
distributions to CWT spectral amplitude statistics.</strong></p>
<dl class="py data">
<dt class="sig sig-object py" id="run_cwt.CWT_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">CWT_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'cwt_conf.json'</span></em><a class="headerlink" href="#run_cwt.CWT_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with configuration parameters
for the CWT step</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_cwt.DIST">
<span class="sig-name descname"><span class="pre">DIST</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#run_cwt.DIST" title="Permalink to this definition"></a></dt>
<dd><p>Name of a statistical distribution to be fit to CWT amps distribution - as
defined by “fit_distribution” key in <cite>CWT_CONFIG_FILE</cite></p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_cwt.FITS">
<span class="sig-name descname"><span class="pre">FITS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#run_cwt.FITS" title="Permalink to this definition"></a></dt>
<dd><p>Global instance of <cite>FitEW</cite> class that stores the distribution fit results</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="run_cwt.FitEW">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FitEW</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.FitEW" title="Permalink to this definition"></a></dt>
<dd><p>An object to calculate and store the fit results of exponentiated Weibul distribution
for all frequencies</p>
<dl class="py method">
<dt class="sig sig-object py" id="run_cwt.FitEW.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.FitEW.__init__" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>amps</strong> (<em>ndarray</em>) – shape (nf, ntimes), float &gt; 0 - spectral amplitudes</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_cwt.INPUT_JSON_FILE">
<span class="sig-name descname"><span class="pre">INPUT_JSON_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'cwt_input.json'</span></em><a class="headerlink" href="#run_cwt.INPUT_JSON_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with input arguments
for individual runs of the CWT step</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_cwt.PREPROC_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">PREPROC_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'preproc_conf.json'</span></em><a class="headerlink" href="#run_cwt.PREPROC_CONFIG_FILE" title="Permalink to this definition"></a></dt>
<dd><p>Name (without a path) for the JSON file with preprocessing parameters
which was used to run filtering/segmentation step</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_cwt.cwt_process_a_channel">
<span class="sig-name descname"><span class="pre">cwt_process_a_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scales</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parm_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.cwt_process_a_channel" title="Permalink to this definition"></a></dt>
<dd><p>Perform all CWT-related processing for a single channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z</strong> (<em>ndarray</em>) – <cite>shape (ntimes,)</cite> - single channel z-score timecourse</p></li>
<li><p><strong>scales</strong> (<em>ndarray</em>) – <cite>shape (nf,)</cite> -  a set of scales for CWT</p></li>
<li><p><strong>parm_dict</strong> (<em>dict</em>) – <cite>conf_dict[“spect_parms”]</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>parm_values</strong> (<em>ndarray</em>) – <cite>shape (nf, nparms)</cite> estimated CWT parameters for all frequencies</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_cwt.estimate_parms">
<span class="sig-name descname"><span class="pre">estimate_parms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parm_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.estimate_parms" title="Permalink to this definition"></a></dt>
<dd><p>For each frequency line, calculate a set of parameters of the
spectral amplitudes distribution. The names of those parameters
are listed in the <cite>cwt_conf.json</cite> file under key “spect_parms”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cwt</strong> (<em>array</em>) – nf x ntimes complex array of wavelet transformation coefficients.</p></li>
<li><p><strong>parm_dict</strong> (<em>dictionary</em>) – keys = parameter names, values = kwargs for corresponding
function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>parm_values</strong> (<em>array</em>) – nf x nparms real value of estimated parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_cwt.fit_res">
<span class="sig-name descname"><span class="pre">fit_res</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.fit_res" title="Permalink to this definition"></a></dt>
<dd><p>Just a wrapper for FITS(amps, parm)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_cwt.loglin_freqs">
<span class="sig-name descname"><span class="pre">loglin_freqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frange</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.loglin_freqs" title="Permalink to this definition"></a></dt>
<dd><p>Calculate a set of frequencies with equally spaced log(f)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frange</strong> (<em>list</em>) – <cite>[fmin, fmax]</cite> target frequency range, Hz</p></li>
<li><p><strong>nf</strong> (<em>int</em>) – number of frequency points; should be &gt; 1</p></li>
<li><p><strong>fs</strong> (<em>float</em>) – sampling frequency, Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fl</strong> (<em>nparray</em>) – shape (nf,) - list of log-spaced frequencies, Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_cwt.plot_distr">
<span class="sig-name descname"><span class="pre">plot_distr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#run_cwt.plot_distr" title="Permalink to this definition"></a></dt>
<dd><p>Plot amplitude distributions for specified channels for a set of
channels. Exponential Weibul distribution is assumed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – full pathname to the .hdf5 file created by
<cite>TFData.write()</cite></p></li>
<li><p><strong>ch_names</strong> (<em>list</em><em> of </em><em>str</em>) – list of channel or ROI names to plot</p></li>
<li><p><strong>freqs</strong> (<em>list</em><em> of </em><em>floats</em><em> or </em><em>None</em>) – Frequencies to plot, Hz. If not specified
all frequencies will be plotted. The frequency will always be adjusted
to the closest ones available in the data.</p></li>
<li><p><strong>title</strong> (<em>str</em><em> or </em><em>None</em>) – plot title</p></li>
<li><p><strong>xlim</strong> (<em>[</em><em>xmin</em><em>, </em><em>xmax</em><em>] or </em><em>None</em>) – X-axis limits</p></li>
<li><p><strong>ylim</strong> (<em>[</em><em>ymin</em><em>, </em><em>ymax</em><em>] or </em><em>None</em>) – Y-axis limits</p></li>
<li><p><strong>nx</strong> (<em>int</em>) – number of x-points to plot in PDF(x)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Nothing</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-tfdata">
<span id="tfdata-py"></span><h2>tfdata.py<a class="headerlink" href="#module-tfdata" title="Permalink to this heading"></a></h2>
<p><strong>The `TFData` class declaration.</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="tfdata.TFData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TFData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parm_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData" title="Permalink to this definition"></a></dt>
<dd><p>An object based on the <cite>xarray.DataArray</cite> class for storing TFD results.
The approach is to use a composition rather than subclassing (inheriting) from
the <cite>DataArray</cite> because inheritance with xarray is shaky and unstable, as the
authors admit themselves - see
<a class="reference external" href="https://docs.xarray.dev/en/stable/internals/extending-xarray.html">https://docs.xarray.dev/en/stable/internals/extending-xarray.html</a>.</p>
<p><cite>TFData</cite> contains a 3-dimensional <cite>DataArray</cite> with shape nchans x nfreqs x nparms as a
<cite>data</cite> attribute. <cite>data</cite> has dimensions (axes) labeled as <cite>‘chan’, ‘frq’, ‘parm’</cite>
respectively. Labels (ticks) along each dimension (the ‘coords’ in the xarray
terminology) are given by lists <cite>ch_names</cite>, <cite>freqs</cite> and <cite>parm_names</cite>, respectively.
If not supplied, integer indices along each dimension will be used.</p>
<p><strong>Attributes</strong></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.CHAN_DIM">
<span class="sig-name descname"><span class="pre">CHAN_DIM</span></span><a class="headerlink" href="#tfdata.TFData.CHAN_DIM" title="Permalink to this definition"></a></dt>
<dd><p>a class constant for the xarray “channels” dimension; set to “chan”</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.FRQ_DIM">
<span class="sig-name descname"><span class="pre">FRQ_DIM</span></span><a class="headerlink" href="#tfdata.TFData.FRQ_DIM" title="Permalink to this definition"></a></dt>
<dd><p>a class constant for the xarray “frequency” dimension; set to “frq”</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.PARM_DIM">
<span class="sig-name descname"><span class="pre">PARM_DIM</span></span><a class="headerlink" href="#tfdata.TFData.PARM_DIM" title="Permalink to this definition"></a></dt>
<dd><p>a class constant for the xarray “parameters” dimension; set to “parm”</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.dim_names">
<span class="sig-name descname"><span class="pre">dim_names</span></span><a class="headerlink" href="#tfdata.TFData.dim_names" title="Permalink to this definition"></a></dt>
<dd><p>a class attribute. Contains symbolic names of the
3 xarray dimensions <cite>CHAN_DIM, FRQ_DIM, PARM_DIM</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.scan_id">
<span class="sig-name descname"><span class="pre">scan_id</span></span><a class="headerlink" href="#tfdata.TFData.scan_id" title="Permalink to this definition"></a></dt>
<dd><p>the ID of the input record.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.ch_names">
<span class="sig-name descname"><span class="pre">ch_names</span></span><a class="headerlink" href="#tfdata.TFData.ch_names" title="Permalink to this definition"></a></dt>
<dd><p>labels along the <cite>CHAN_DIM</cite> dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.freqs">
<span class="sig-name descname"><span class="pre">freqs</span></span><a class="headerlink" href="#tfdata.TFData.freqs" title="Permalink to this definition"></a></dt>
<dd><p>labels along the <cite>FRQ_DIM</cite> dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of floats or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.parm_names">
<span class="sig-name descname"><span class="pre">parm_names</span></span><a class="headerlink" href="#tfdata.TFData.parm_names" title="Permalink to this definition"></a></dt>
<dd><p>labels along the <cite>PARM_DIM</cite> dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tfdata.TFData.data">
<span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#tfdata.TFData.data" title="Permalink to this definition"></a></dt>
<dd><p>the internal xarray object that stores the data</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xarray</p>
</dd>
</dl>
</dd></dl>

<p><strong>Methods</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parm_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>(</em><em>int</em><em>, </em><em>int</em><em>, </em><em>int</em><em>)</em>) – an integer tuple (nchans, nfreqs, nparms)</p></li>
<li><p><strong>scan_id</strong> (<em>str</em><em> or </em><em>None</em>) – the ID of the input record</p></li>
<li><p><strong>values</strong> (<em>xarray</em><em>, </em><em>ndarray</em><em> or </em><em>None</em>) – initial values for self.xarray; NaNs if not provided</p></li>
<li><p><strong>ch_names</strong> (<em>list</em><em> of </em><em>str</em><em> of </em><em>None</em>) – labels along the <cite>CHAN_DIM</cite> (‘chan’) dimension</p></li>
<li><p><strong>freqs</strong> (<em>list</em><em> of </em><em>floats</em><em> or </em><em>None</em>) – labels along the <cite>FRQ_DIM</cite> (‘frq’) dimension</p></li>
<li><p><strong>parm_names</strong> (<em>list</em><em> of </em><em>str</em><em> of </em><em>None</em>) – labels along the <cite>PARM_DIM</cite> (‘parm’) dimension</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.get_fixed_f_slice">
<span class="sig-name descname"><span class="pre">get_fixed_f_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.get_fixed_f_slice" title="Permalink to this definition"></a></dt>
<dd><p>Get a 2D <cite>chans x parms</cite> slice corresponding to some
frequency value. If the requested frequency does not match
any of the available frequencies, the closest of available
frequencies will be chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>f</strong> (<em>float</em>) – requested frequency, Hz</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>xa</strong> (<em>xarray</em>) – <cite>chans x parms</cite> slice</p></li>
<li><p><strong>factual</strong> (<em>float</em>) – the actual frequency correspondig to the returned
data, Hz</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.get_nearest_freq">
<span class="sig-name descname"><span class="pre">get_nearest_freq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.get_nearest_freq" title="Permalink to this definition"></a></dt>
<dd><p>Get the nearest actual frequency value for the requested
frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>f</strong> (<em>float</em>) – requested frequency, Hz</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fnearest</strong> (<em>float</em>) – the nearest frequency value among
the frequencies defined for the frequency dimension, Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.read" title="Permalink to this definition"></a></dt>
<dd><p>Read TFData object from the .hdf5 file created by the write() method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – <cite>.hdf5</cite> file name to read from, that was created by a call to
<cite>TFData.write()</cite> method.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tfd</strong> (<em>TFData</em>) – an instance of TFData class reconstructed from the file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.to_pandas" title="Permalink to this definition"></a></dt>
<dd><p>Select a 2D slice of the TFData data and convert it to a
pandas dataframe. The slices are either <cite>freqs x parms</cite>
for a single channel, or <cite>chans x parms</cite> for a fixed frequency
value. Specific type is chosen depending on which argument
(<cite>chan</cite> or <cite>freq</cite>) is given. For fixed frequency slices, the
frequency closest to the requested among the available ones is
chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chan</strong> (<em>str</em><em> or </em><em>None</em>) – the channel name for <cite>freqs x parms</cite>
slice</p></li>
<li><p><strong>freq</strong> (<em>float</em><em> or </em><em>None</em>) – the frequency value for <cite>chans x parms</cite>
slice</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>df</strong> (<em>DataFrame</em>) – pandas dataframe</p></li>
<li><p><strong>arg</strong> (<em>str or float</em>) – the actual value of the argument (<cite>chan</cite> or <cite>freq</cite>)
used. This is mostly used for frequencies when exact frequency
values available may not match the requested frequency. For
fixed channel slices the <cite>chan</cite> argument value is always returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfdata.TFData.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tfdata.TFData.write" title="Permalink to this definition"></a></dt>
<dd><p>Write this TFData object to the .hdf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – file name to save to. User is expected to properly
set the <cite>fname</cite>’s extention to <cite>.hdf5</cite> to reflect the file type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Nothing</strong></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-view_raw_eeg">
<span id="view-raw-eeg-py"></span><h2>view_raw_eeg.py<a class="headerlink" href="#module-view_raw_eeg" title="Permalink to this heading"></a></h2>
<p><strong>A simple viewer of the MNE Python raw data. Can be used both standalone and
as a function call.</strong></p>
</section>
<section id="module-view_inflated_brain_data">
<span id="view-inflated-brain-data-py"></span><h2>view_inflated_brain_data.py<a class="headerlink" href="#module-view_inflated_brain_data" title="Permalink to this heading"></a></h2>
<p><strong>A utility for displaying functional data on a brain surface.</strong></p>
<p>May be called as a function, or run standalone (see the unit test
code at the end of the file).</p>
<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.expand_data_to_rois">
<span class="sig-name descname"><span class="pre">expand_data_to_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.expand_data_to_rois" title="Permalink to this definition"></a></dt>
<dd><p>Expand ROI single data values to all ROI vertices.</p>
<p>For example, when one has one value per ROI in the atlas, these values
will be properly extended to all vertices of hemisphere surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>ndarray</em>) – 1D array, <cite>shape = (nlabels,)</cite>; data values
assigned to ROIs (labels)
vertex values</p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of <cite>nlabels</cite> ROI Label objects</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>vdata</strong> (<em>ndarray</em>) – 1D array; data values for all vertices in all labels</p></li>
<li><p><strong>vertices</strong> (<em>ndarray</em>) – 1D array; vertex numbers for each data value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.plot_rr">
<span class="sig-name descname"><span class="pre">plot_rr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.plot_rr" title="Permalink to this definition"></a></dt>
<dd><p>Display points specified by 3D spatial positions on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em>) – an instance of MNE Brain class</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em>) – <cite>npoints x 3</cite> array of MRI coordinates, in meters. It is assumed that
points with negative <cite>x</cite> are referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Generally this is not exactly so
but should be correct for the <cite>fsaverage</cite> template.</p></li>
<li><p><strong>map_to_cortex</strong> (<em>Bool</em>) – flag whether foci will be mapped to the closest vertex
on the cortical surface, or left as is. Ignored when vertno is provided.
Note that if <cite>map_to_cortex == False</cite> rr’s will never land onto the
inflated surface even if they do belong to the original (not inflated) cortical
surface.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color</strong> (<em>color</em>) – color of dots in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – opacity in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.plot_vertices">
<span class="sig-name descname"><span class="pre">plot_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.plot_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Display points specified by vertex numbers on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em>) – an instance of MNE Brain class</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color</strong> (<em>color</em>) – color of dots in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – opacity in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.view_inflated_brain_data">
<span class="sig-name descname"><span class="pre">view_inflated_brain_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atlas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_atlas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'both'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbar_lims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rois_to_mark</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subjects_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_dots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inflated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs_brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.view_inflated_brain_data" title="Permalink to this definition"></a></dt>
<dd><p>A utility for displaying data on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em><em> or </em><em>None</em>) – an instance of the Brain class. If supplied,
it will be used for plotting, otherwise a new one will be created.</p></li>
<li><p><strong>atlas</strong> (<em>str</em><em> or </em><em>None</em>) – name of the parcellation to diplay</p></li>
<li><p><strong>show_atlas</strong> (<em>bool</em>) – if <cite>True</cite> parcellation will be displayed</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’.</p></li>
<li><p><strong>title</strong> (<em>str</em><em> or </em><em>None</em>) – a title for the plot.</p></li>
<li><p><strong>data</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D array of <cite>nvertno</cite> floating point values, where
<cite>nvertno = len(vertno)</cite>. If data is not <cite>None</cite>, <cite>vertno</cite> should also
be given. <cite>data</cite> and <cite>vertno</cite> should have the same length.</p></li>
<li><p><strong>cbar_lims</strong> (<em>(</em><em>float</em><em>,</em><em>float</em><em>) or </em><em>None</em>) – (fmin, fmax) color bar limits for the data.
If <cite>None</cite>, those will be set automatically.</p></li>
<li><p><strong>colormap</strong> (<em>str</em><em>, </em><em>list</em><em> of </em><em>color</em><em>, or </em><em>array</em>) – as is. Typically a string defining
the palette name, or ‘auto’. See
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em>
for details and other options.</p></li>
<li><p><strong>alpha_data</strong> (<em>float</em>) – opacity of the data overlay on the cortex surface</p></li>
<li><p><strong>smoothing_steps</strong> (<em>int</em><em> or </em><em>'Nearest'</em><em> or </em><em>None</em>) – smoothing when plotting data. <cite>int</cite>
value explicitly sets the number of vertices for smoothing. For other
settings see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em></p></li>
<li><p><strong>rois_to_mark</strong> (<em>list</em><em> or </em><em>None</em>) – if supplied, a list of names of ROIs (labels)
or a list of Label objects. In the first case <cite>atlas</cite> cannot be <cite>None</cite>,
and the name should belong to this atlas. In the 2nd case a ROI from
any surface atlas can be displayed; mind not using <cite>Label</cite> objects
restricted to a (coarse) source space - those won’t show up correctly.
The specified ROIs will be shown with thicker borders.</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
<li><p><strong>show_vertices</strong> (<em>bool</em>) – If <cite>True</cite>, the vertices pointed to by vertno will be
plotted. Default <cite>False</cite>.</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em><em> or </em><em>None</em>) – <cite>nr x 3</cite>; a list of locations in MRI coordinates to plot. Those
will be projected to the nearest cortex location if <cite>map_to_cortex</cite> is <cite>True</cite>.
Importantly, <strong>`rr`’s are NOT “inflated” when plotted</strong>. Specifically, <strong>if
the inflated surface is used (Default), and `map_to_cortex` is `False`,
then points that actually belong to the surface will be displayed off
the surface</strong>. In view of this an exception is thrown when trying to
plot rr’s with <cite>inflated = True</cite> and <cite>map_to_cortex = False</cite>. Use a
non-inflated surface to properly display rr’s relative to the brain.</p></li>
<li><p><strong>map_to_cortex</strong> (<em>bool</em>) – flag whether rr’s will be mapped to the closest vertex
on the cortical surface, of left as is.</p></li>
<li><p><strong>subjects_dir</strong> (<em>str</em>) – a pathname to the folder containing the
FreeSurfer results for a subject whose brain surface is used for display.
Typically this is the <cite>fsaverage</cite> subject template data folder.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color_dots</strong> (<em>color</em>) – color of plotted spheres (dots) for vertices (if shown)
or rr’s, in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha_cortex</strong> (<em>float</em>) – opacity of the cortex surface and the dots (spheres) if
vertices or rr’s are plotted; should be in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Display the window as soon as it is ready. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>block</strong> (<em>bool</em>) – If <cite>True</cite>, start the Qt application event loop. Default to <cite>False</cite>.</p></li>
<li><p><strong>inflated</strong> (<em>bool</em>) – If <cite>True</cite>, (default) show inflated pial surface.</p></li>
<li><p><strong>kwargs_brain</strong> (<em>dict</em><em> or </em><em>None</em>) – if needed, more arguments to the Brain class constructor
in addition to those listed above; see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html</em>
for details.</p></li>
<li><p><strong>kwargs_data</strong> (<em>dict</em>) – if needed, more arguments to the Brain.add_data() method
in addition to those listed above; see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em>
for details.</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbosity level; one of ‘DEBUG’, ‘INFO’,
‘WARNING’, ‘ERROR’, ‘CRITICAL’ or None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>brain</strong> (<em>Brain</em>) – the new or old instance of the Brain class</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-plot_alpha_power">
<span id="plot-alpha-power-py"></span><h2>plot_alpha_power.py<a class="headerlink" href="#module-plot_alpha_power" title="Permalink to this heading"></a></h2>
<p><strong>A top level script to display alpha-band source power distribution on the cortex surface.</strong></p>
</section>
<section id="module-running_mean_std">
<span id="running-mean-std-py"></span><h2>running_mean_std.py<a class="headerlink" href="#module-running_mean_std" title="Permalink to this heading"></a></h2>
<p>Calculate mean and STD of a stream of data.</p>
<dl class="simple">
<dt>Source:</dt><dd><p><a class="reference external" href="https://www.johndcook.com/blog/standard_deviation/">https://www.johndcook.com/blog/standard_deviation/</a>
<a class="reference external" href="https://stackoverflow.com/questions/895929/how-do-i-determine-the-standard-deviation-stddev-of-a-set-of-values">https://stackoverflow.com/questions/895929/how-do-i-determine-the-standard-deviation-stddev-of-a-set-of-values</a></p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RunningMeanSTD</span></span><a class="headerlink" href="#running_mean_std.RunningMeanSTD" title="Permalink to this definition"></a></dt>
<dd><p>This class’ purpose is to calculate a running value of the mean and
variance (or standard deviation) of a stream of data. Each data item
may be a scalar or a numpy ndarray.</p>
<p>Methods:</p>
<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.counter">
<span class="sig-name descname"><span class="pre">counter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.counter" title="Permalink to this definition"></a></dt>
<dd><p>Return current number of accumulated data points</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.is_array">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.is_array" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> – data item from the stream</p>
</dd>
</dl>
<dl class="simple">
<dt>Returns</dt><dd><p><cite>True</cite> for non-scalar data types, <cite>False</cite> otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.mean" title="Permalink to this definition"></a></dt>
<dd><p>Return currently accumulated average</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.push" title="Permalink to this definition"></a></dt>
<dd><p>Add new data item <cite>v</cite> from the stream to accumulated statistics.
All the magic happens here.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> – data item from the stream</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>nothing</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.reset" title="Permalink to this definition"></a></dt>
<dd><p>Clear all accumulated data and reinitialize the object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.std">
<span class="sig-name descname"><span class="pre">std</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.std" title="Permalink to this definition"></a></dt>
<dd><p>Return currently accumulated standard deviation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="running_mean_std.RunningMeanSTD.var">
<span class="sig-name descname"><span class="pre">var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#running_mean_std.RunningMeanSTD.var" title="Permalink to this definition"></a></dt>
<dd><p>Return currently accumulated variance</p>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="README.html" class="btn btn-neutral float-left" title="EEG preprocessing pipeline for FHA EDF dataset" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="README_reports.html" class="btn btn-neutral float-right" title="EEG clinical reports processing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, AM.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>