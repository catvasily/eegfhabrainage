
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Classes and functions &#8212; eegfh 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="EEG preprocessing pipeline for FHA EDF dataset" href="README.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="classes-and-functions">
<h1>Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this heading">¶</a></h1>
<p>Python modules, classes and functions used in preprocessing.</p>
<section id="module-run_filtering_segmentation">
<span id="run-filtering-segmentation-py"></span><h2>run_filtering_segmentation.py<a class="headerlink" href="#module-run_filtering_segmentation" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="run_filtering_segmentation.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#run_filtering_segmentation.get_data_folders" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output
data folders, and a flag indicating whether host is on CC cluster</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-edf_preprocessing">
<span id="edf-preprocessing-py"></span><h2>edf_preprocessing.py<a class="headerlink" href="#module-edf_preprocessing" title="Permalink to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="edf_preprocessing.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'preproc_conf.json'</span></em><a class="headerlink" href="#edf_preprocessing.JSON_CONFIG_FILE" title="Permalink to this definition">¶</a></dt>
<dd><p>Default name (without a path) for the JSON file with preprocessing parameters. It is expected
to reside in the same folder as the <em>edf_preprocessing.py</em> source file.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PreProcessing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notch_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flat_parms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing" title="Permalink to this definition">¶</a></dt>
<dd><p>The class’s aim is preprocessing clinical EEG recordings (in EDF format)
and make them a suitable input for a later analysis and ML applications.</p>
<p>The class instantiates a preprocessing object which
carries a Raw EDF file through a sequence of operations:</p>
<ol class="arabic simple">
<li><p>resample each recording’s signal to traget frequency</p></li>
<li><p>keeps only signal with frequencies in selected range</p></li>
<li><p>identifies timestamps of hyperventilation (HV), photic stimulation (PhS)
and flat (zero) signal (together - “bad” intervals)</p></li>
<li><p>extract EEG segment(s) of needed length from “good” intervals</p></li>
</ol>
<p>Then the object can save extracted segment(s) into new EDF files
OR return a Pandas DataFrame with data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> (<em>str</em>) – the EDF file pathname</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters.
The default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant.</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>target_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of mandatory channels to read from the EDF
file.</p></li>
<li><p><strong>exclude_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of channels to be excluded when reading
the EDF file.</p></li>
<li><p><strong>target_frequency</strong> (<em>int</em>) – the final EEG frequency after resampling</p></li>
<li><p><strong>lfreq</strong> (<em>float</em>) – lower frequency boundary of the signal to keep</p></li>
<li><p><strong>hfreq</strong> (<em>float</em>) – higher frequency boundary of the signal to keep</p></li>
<li><p><strong>notch_freq</strong> (<em>float</em>) – notch frequency (typically - power line frequency)</p></li>
<li><p><strong>flat_parms</strong> (<em>dict</em>) – parameters for flat intervals selection. Should contain the
following keys:
<em>‘flat_max_ptp’</em> - the channel’s amplitude max peak-to-peak value (in channel’s
units) for this channel to be marked as flat;
<em>‘bad_percent’</em> - min percentage of the time the channel’s peak
to peak is below the <em>‘flat_max_ptp’</em> threshold to be considered flat;
<em>‘min_duration’</em> - minimum interval in seconds for all consecutive samples to
be below the <em>‘flat_max_ptp’</em> to indicate a flat interval.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If both <em>conf_json</em> and <em>conf_dict</em>
are omitted in the constructor, the default settings will be read from <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> which should
be present in the same folder as the <em>edf_preprocessing.py</em>.</p></li>
<li><p>When not None, the explicitly specified parameter values will be used instead of the values
given by corresponding keys in <em>conf_json</em> or <em>conf_dict</em>.</p></li>
</ul>
</div>
<p><strong>Attributes</strong></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.filename">
<span class="sig-name descname"><span class="pre">filename</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>EDF file path</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.conf_dict">
<span class="sig-name descname"><span class="pre">conf_dict</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.conf_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>a dictionary with configuration parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.target_channels">
<span class="sig-name descname"><span class="pre">target_channels</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.target_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of mandatory channels to read from the EDF
file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.exclude_channels">
<span class="sig-name descname"><span class="pre">exclude_channels</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.exclude_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of channels to be excluded when reading
the EDF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.target_frequency">
<span class="sig-name descname"><span class="pre">target_frequency</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.target_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>the final EEG frequency after resampling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.raw" title="Permalink to this definition">¶</a></dt>
<dd><p>the raw EDF object</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mne.Raw</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.sfreq">
<span class="sig-name descname"><span class="pre">sfreq</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.sfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>initial sampling frequency of EEG</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.flat_parms">
<span class="sig-name descname"><span class="pre">flat_parms</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.flat_parms" title="Permalink to this definition">¶</a></dt>
<dd><p>parameters for flat intervals selection (see above)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.bad_intervals">
<span class="sig-name descname"><span class="pre">bad_intervals</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.bad_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of the [start, end] pairs with timestamps in seconds,
indicating starts and ends of bad intervals (HV, PhS, flat signal)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.clean_intervals">
<span class="sig-name descname"><span class="pre">clean_intervals</span></span><a class="headerlink" href="#edf_preprocessing.PreProcessing.clean_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of the [start, end] pairs with timestamps in seconds,
indicating starts and ends of segments to be extracted</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<p><strong>Methods</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.create_intervals_data">
<span class="sig-name descname"><span class="pre">create_intervals_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.create_intervals_data" title="Permalink to this definition">¶</a></dt>
<dd><p>The function updates and returns intervals_df - a DataFrame
with the EEG data based on timestamps from <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a>.
Prints warning if no clean segments were found.</p>
<p>The DataFrame has the following columns:</p>
<ul class="simple">
<li><p>scan_id - ID of the EEG recording.</p></li>
<li><p>interval_start - timestamp in datapoints of the segment start.</p></li>
<li><p>interval_length - length in datapoints of the segment.</p></li>
<li><p>data - numpy array of the EEG amplitude data, with shape
(&lt;n_target_channels&gt;, length in seconds x sampling frequency).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>self.interval_df</strong> (<em>DataFrame</em>) – a dataframe with extracted segments</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Saving this dataframe into a CSV file will truncate the content
of the ‘data’ column and convert it to a string, so the data will be lost.
Recommend to save the data into .npy file separately and keep the .csv
for later matching with labels.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.extract_good">
<span class="sig-name descname"><span class="pre">extract_good</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.extract_good" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the functions above to identify “bad” intervals and
updates the attribute <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a> with timesptamps to extract</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_length</strong> (<em>float</em>) – length in seconds of the segments to be extracted
from this EEG recording; the value from <cite>self.conf_dict</cite> will be used
if not specified</p></li>
<li><p><strong>target_segments</strong> (<em>int</em>) – a total number of the segments to extract
from this EEG recording; the value from <cite>self.conf_dict</cite> will be used
if not specified</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.flat_intervals">
<span class="sig-name descname"><span class="pre">flat_intervals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.flat_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify beginning and end times of flat signal</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – List of <em>[start, end]</em> time values
for each interval</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.hyperventilation">
<span class="sig-name descname"><span class="pre">hyperventilation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.hyperventilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify beginning and end of hyperventilation from EEG data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – [[start1, end1],…,[startN, endN]] or []: a list of start and end times
of hyperventilation intervals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.photic_stimulation">
<span class="sig-name descname"><span class="pre">photic_stimulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.photic_stimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify beginning and end times of photic stimulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intervals</strong> (<em>list</em>) – [[start1, end1],…,[startN, endN]] or []: a list of start and end times
of photic stimulation series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="edf_preprocessing.PreProcessing.save_edf">
<span class="sig-name descname"><span class="pre">save_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.PreProcessing.save_edf" title="Permalink to this definition">¶</a></dt>
<dd><p>The function writes out new EDF file(s) based on <a class="reference internal" href="#edf_preprocessing.PreProcessing.clean_intervals" title="edf_preprocessing.PreProcessing.clean_intervals"><code class="xref py py-data docutils literal notranslate"><span class="pre">clean_intervals</span></code></a> timestamps.
It saves each segment into a separate EDF file, with suffixes “[scan_id]_1”,
“[scan_id]_2”, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>folder</strong> (<em>str</em>) – where to save the new EDF files</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – main name for the output files (suffix will be added for more than 1 files)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>success</strong> (<em>bool</em>) – <cite>True</cite> if clean interval(s) exist and are saved, <cite>False</cite> otherwise</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.assign_known_channel_types">
<span class="sig-name descname"><span class="pre">assign_known_channel_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.assign_known_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Set channel types based on type information available in <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the Raw object; channel data does not need to be preloaded</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
Default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with known channel types (see below). If None,
this dictionary will be created</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with keys representing channel types and values as
lists of corresponding channel names. If supplied as an argument,
its keys (if present) will be updated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.load_edf_data">
<span class="sig-name descname"><span class="pre">load_edf_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_csv_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.load_edf_data" title="Permalink to this definition">¶</a></dt>
<dd><p>The function loads multiple EDF files and returns data
with lables suitable for analysis and machine learning models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_folder</strong> (<em>str</em>) – folder with EDF files</p></li>
<li><p><strong>labels_csv_path</strong> (<em>str</em>) – CSV dile containing scan_ids and label (age)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>X</strong> (<em>NumPy array</em>) – EEG amplitudes from EDF files, having
shape of ([n_samples], 20, [length in seconds] x [sampling frequency])</p></li>
<li><p><strong>labels</strong> (<em>NumPy array</em>) – age labels corresponding to each sample from X</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function fits a very specific CSV file ‘age_ScanID.csv’,
so it’s looking for columns ‘ScanID’ for scan ids, ‘AgeYears’ for age labels.
You might want to adjust column names in your own file or change this function.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.read_edf">
<span class="sig-name descname"><span class="pre">read_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preload</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.read_edf" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads an EDF file with the MNE package, creates the Raw EDF object.
Excludes some channels to keep only target ones plus possibly some additional
non-eeg channels.</p>
<p>All target channels are set to be ‘eeg’ type - that is, EEG sensor type
Channels with names matching those in EOG, ECG channels lists are set to be
‘eog’, ‘ecg’ types respectively. All other included channels are set to be of ‘misc’ type.</p>
<p>Raises an exception in case the input recording  doesn’t have all
mandatory channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> (<em>str</em>) – EDF file pathname</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
Default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters; in
particular it must contain keys <em>“target_channels”</em> and <em>“exclude_channels”</em>.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>target_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of mandatory channels to read from the EDF
file. If supplied, <em>target_channels</em> list will be used instead of the one provided
by either of the <em>conf_…</em> arguments.</p></li>
<li><p><strong>exclude_channels</strong> (<em>list</em><em> of </em><em>str</em>) – a list of channels to be excluded when reading
the EDF file. If supplied, <em>exlclude_channels</em> list will be used instead of the one provided
by either of <em>conf_…</em> arguments.</p></li>
<li><p><strong>preload</strong> (<em>Bool</em>) – (default True) flag to read all the data into memory</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Raw</strong> (<em>mne.Raw</em>) – raw EDF object</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If both <em>conf_json</em> and <em>conf_dict</em> are omitted in the function call, the default settings will be read from</p>
<p><a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> which should be present in the same folder as the <em>edf_preprocessing.py</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="edf_preprocessing.slice_edfs">
<span class="sig-name descname"><span class="pre">slice_edfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_folder</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_scan_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hfreq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'good'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#edf_preprocessing.slice_edfs" title="Permalink to this definition">¶</a></dt>
<dd><p>The function runs a pipeline for preprocessing and extracting
clean segment(s) of requested length from multiple EDF files.
It takes in a list of EDF file names and preprocessing parameters,
looks up for the files in source folder, and performs preprocessing
and extraction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_folder</strong> (<em>str</em>) – a pathname to the folder with EDF files</p></li>
<li><p><strong>target_folder</strong> (<em>str</em>) – a pathname to the output folder where the extracted segments
will be saved in EDF format</p></li>
<li><p><strong>conf_json</strong> (<em>str</em>) – pathname of a json file with configuration parameters.
The default configuration file name is given by <a class="reference internal" href="#edf_preprocessing.JSON_CONFIG_FILE" title="edf_preprocessing.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a> constant.</p></li>
<li><p><strong>conf_dict</strong> (<em>dict</em>) – a dictionary with configurartion parameters.
If both <em>conf_json</em> and <em>conf_dict</em> are given, the latter is used.</p></li>
<li><p><strong>source_scan_ids</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>None</em>) – a list of short EDF file names without .edf
extention to preprocess. If None, all .edf files in the source directory will
be preprocessed, up to a limit set by the <em>nfiles</em> argument</p></li>
<li><p><strong>target_frequency</strong> (<em>num</em><em> or </em><em>None</em>) – the final EEG frequency after resampling; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>lfreq</strong> (<em>float</em><em> or </em><em>None</em>) – the lower frequency boundary of the EEG signal in Hz; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>hfreq</strong> (<em>float</em><em> or </em><em>None</em>) – the higher frequency boundary of the EEG signal in Hz; if not specified
the default for the :class: <cite>PreProcessing</cite> will be used</p></li>
<li><p><strong>extract</strong> (<em>str</em>) – one of ‘good’ (default) or ‘HV’. In the first case good segments (no artifacts
stimuli, etc. present). In the 2nd case hyperventilation intervals will be extracted.</p></li>
<li><p><strong>target_length</strong> (<em>float</em>) – the length of each of the extracted segments in seconds; the value
from <cite>conf_json</cite> or <cite>conf_dict</cite> will be used if not specified. Only applies when
<cite>extract = ‘good’</cite>. In HV case the length will be equal to that of 1st HV interval.</p></li>
<li><p><strong>target_segments</strong> (<em>int</em>) – the maximum number of segments to extract from each EDF file; the value
from <cite>conf_json</cite> or <cite>conf_dict</cite> will be used if not specified. Only applies when
<cite>extract = ‘good’</cite>. In HV case only the 1st HV interval will be extracted.</p></li>
<li><p><strong>nfiles</strong> (<em>int</em><em> or </em><em>None</em>) – the max number of the source files to preprocess; (default = None = no limit)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-individual_func">
<span id="individual-func-py"></span><h2>individual_func.py<a class="headerlink" href="#module-individual_func" title="Permalink to this heading">¶</a></h2>
<p>saving the file as .edf</p>
<p>Created on Wed Dec  5 12:56:31 2018
&#64;author: skjerns</p>
<p>Gist to save a mne.io.Raw object to an EDF file using pyEDFlib
(<a class="reference external" href="https://github.com/holgern/pyedflib">https://github.com/holgern/pyedflib</a>)</p>
<p>Disclaimer:</p>
<ul class="simple">
<li><p>Saving your data this way will result in slight
loss of precision (magnitude +-1e-09).</p></li>
<li><p>It is assumed that the data is presented in Volt (V),
it will be internally converted to microvolt</p></li>
<li><p>BDF or EDF+ is selected based on the filename extension</p></li>
<li><p>Annotations are lost in the process.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="individual_func.prefilter_string">
<span class="sig-name descname"><span class="pre">prefilter_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.prefilter_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate channel prefilter string like “HP:0.5Hz LP:55Hz N:60Hz”</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that <cite>info[“lowpass”]</cite> and <cite>info[“high pass”]</cite> values
describe a bandpass filter applied to EEG channels only; notch
filter info applies to EEG channels plus EOG, ECG channels;
both bandpass and notch filters info is ignored for other channel types.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>info</strong> (<em>MNE info</em>) – as is</p></li>
<li><p><strong>ch_num</strong> (<em>int</em>) – 0-based channel number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>s</strong> (<em>string</em>) – the prefilter string described above (possibly empty)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.read_notch_info">
<span class="sig-name descname"><span class="pre">read_notch_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.read_notch_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Read notch frequency (if any) from the raw.info[“description”] string.
It is assumed that if notch filtering was performed, its frequency was
saved with the raw.info object using the <a class="reference internal" href="#individual_func.save_notch_info" title="individual_func.save_notch_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">save_notch_info</span></code></a> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>info</strong> (<em>MNE info</em>) – as is</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>notch_freq</strong> (<em>float or None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.safe_crop">
<span class="sig-name descname"><span class="pre">safe_crop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.safe_crop" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for raw.crop() method which properly adjusts timings of
annotations.</p>
<p>In MNE v1.3 at least for EDF recordings we are dealing with the cropped raw object
annotations still have onsets relative to the start of the original (uncropped) data.
Such behavior might be by design - see extremely confusing explanations
about the <a class="reference external" href="https://mne.tools/stable/generated/mne.Annotations.html#mne.Annotations">Annotations</a>
class.</p>
<p>This function checks if annotation timings were corrected after cropping,
and applies correction if they were not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>MNE Raw</em>) – an object to be cropped</p></li>
<li><p><strong>args</strong> (<em>other</em>) – arguments to be passed to the
<a class="reference external" href="https://mne.tools/stable/generated/mne.io.Raw.html#mne.io.Raw.crop">Raw.crop()</a> method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>raw</strong> (<em>MNE Raw</em>) – the modified in place cropped raw object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.save_notch_info">
<span class="sig-name descname"><span class="pre">save_notch_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notch_freq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.save_notch_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Save notch filter frequency to <cite>raw.info[“description”]</cite> string.
This may be necessary because MNE does not save the notching info neither with
the Raw object nor in the FIF file. This is implemented by appending to the
value of the “description” key the following string:</p>
<p><cite>“Notch filter: {} Hz”.format(notch_freq)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>info</strong> (<em>MNE info</em>) – as is</p></li>
<li><p><strong>notch_freq</strong> (<em>float</em><em> or </em><em>int</em>) – the notching frequency, Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None; info[“description”] key is updated in place</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.select_chans">
<span class="sig-name descname"><span class="pre">select_chans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ch_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">belong</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.select_chans" title="Permalink to this definition">¶</a></dt>
<dd><p>From the input channel list <cite>ch_list</cite> select channels that belong to the <cite>target list</cite>.
The string comparison is performed case insensitive, but original case is
preserved in the returned list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ch_list</strong> (<em>list</em><em> of </em><em>str</em>) – input channel list</p></li>
<li><p><strong>target_list</strong> (<em>list</em><em> of </em><em>str</em>) – a target channel list</p></li>
<li><p><strong>belong</strong> (<em>bool</em>) – <cite>True</cite> (default) if request is to find channels that belong to the target list,
<cite>False</cite> if one wants channels that do NOT belong to the target list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>selected_channels, flags</strong></p></li>
<li><p><strong>selected_channels</strong> (<em>list of str</em>) – a list of channels from the input list
that belong to the <cite>target list</cite></p></li>
<li><p><strong>flags</strong> (<em>list of bool</em>) – list of flags indicating if elements of <cite>ch_list</cite>
belong / not belong to the <cite>target_list</cite>; <cite>len(flags)</cite> equals to <cite>len(ch_list)</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.set_channel_types">
<span class="sig-name descname"><span class="pre">set_channel_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ch_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data channel types based on their names.</p>
<p>If a channel name belongs to the <cite>type_list</cite> (case-insensitive),
then corresponding channel’s type will be set to the <cite>type_name</cite>.
The raw object will also be updated. As a result,
<cite>ch_groups[type_name]</cite> will contain all channels belonging to
the type including those that were previously marked as such in the
<cite>self.raw`object</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the Raw object; channel data does not need to be preloaded</p></li>
<li><p><strong>type_name</strong> (<em>str</em>) – the channel type, such as ‘eog’, ‘ecg’, ‘eeg’, etc.</p></li>
<li><p><strong>type_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of known channel names that belong to this type.</p></li>
<li><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with known channel types (see below). If None,
this dictionary will be created</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ch_groups</strong> (<em>dict</em>) – a dictionary with keys corresponding to channel types and
values being lists of corresponding channel names. If supplied as an argument,
its key equal to <cite>type_name</cite> will be updated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="individual_func.write_mne_edf">
<span class="sig-name descname"><span class="pre">write_mne_edf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mne_raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">picks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#individual_func.write_mne_edf" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the raw content of a <cite>MNE.io.Raw</cite> and its subclasses to
a file using the EDF+/BDF filetype
pyEDFlib is used to save the raw contents of the RawArray to disk</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mne_raw</strong> (<em>mne.io.Raw</em>) – An object with super class <cite>mne.io.Raw</cite> that contains the data
to save</p></li>
<li><p><strong>fname</strong> (<em>string</em>) – File name of the new dataset. This has to be a new filename
unless data have been preloaded. Filenames should end with .edf</p></li>
<li><p><strong>picks</strong> (<em>array-like</em><em> of </em><em>int</em><em> or </em><em>None</em>) – Indices of channels to include. If <cite>None</cite> all channels are kept.</p></li>
<li><p><strong>tmin</strong> (<em>float</em><em> | </em><em>None</em>) – Time in seconds of first sample to save. If <cite>None</cite> first sample
is used.</p></li>
<li><p><strong>tmax</strong> (<em>float</em><em> | </em><em>None</em>) – Time in seconds of last sample to save. If <cite>None</cite> last sample
is used.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em>) – If <cite>True</cite>, the destination file (if it exists) will be overwritten.
If <cite>False</cite> (default), an error will be raised if the file exists.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-do_pyprep">
<span id="do-pyprep-py"></span><h2>do_pyprep.py<a class="headerlink" href="#module-do_pyprep" title="Permalink to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="do_pyprep.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'pyprep_ica_conf.json'</span></em><a class="headerlink" href="#do_pyprep.JSON_CONFIG_FILE" title="Permalink to this definition">¶</a></dt>
<dd><p>Default name (without a path) for the JSON file with parameter settings for
the PYPREP procedure and ICA artifact removal. This file is expected
to reside in the same folder as the <em>do_pyprep.py</em> source file.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="do_pyprep.Pipeline">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_json</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_pyprep.Pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>The class’ aim is preprocessing clean extracted segments of clinical
EEG recordings (in EDF format) and make them a suitable input for later analysis
and ML applications.</p>
<p>The class instantiates a preprocessing object which
carries a Raw EDF file through the following operations:
1. Removes power lines, re-references the channels and identifies bad channels
as per the PREP pipeline.</p>
<p>2. Performs ICA on the given EEG segment for both EOG and ECG channels.
Then the object returns a pre-processed EEG data in raw format.</p>
<p><strong>Attributes</strong></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.conf_dict">
<span class="sig-name descname"><span class="pre">conf_dict</span></span><a class="headerlink" href="#do_pyprep.Pipeline.conf_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>a dictionary containing all settings; typically reflects
contents of the JSON file <a class="reference internal" href="#do_pyprep.JSON_CONFIG_FILE" title="do_pyprep.JSON_CONFIG_FILE"><code class="xref py py-data docutils literal notranslate"><span class="pre">JSON_CONFIG_FILE</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.ch_groups">
<span class="sig-name descname"><span class="pre">ch_groups</span></span><a class="headerlink" href="#do_pyprep.Pipeline.ch_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>a dictionary containing lists of channels of certain types</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><a class="headerlink" href="#do_pyprep.Pipeline.raw" title="Permalink to this definition">¶</a></dt>
<dd><p>the MNE Raw EDF object</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mne.Raw</p>
</dd>
</dl>
</dd></dl>

<p><strong>Methods</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.applyPipeline">
<span class="sig-name descname"><span class="pre">applyPipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">applyICA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_postprep_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_postprep_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_postica_png</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.applyPipeline" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Applies the pipeline (resampling, filtering, applying PREP, performing ICA)</dt><dd><p>on the given EEG segment</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>applyICA</strong> (<em>bool</em>) – flag to remove EOG, ECG - related ICs from the signals</p></li>
<li><p><strong>view_plots</strong> (<em>bool</em>) – flag to show tons of plots; execution will be paused
each time a plot is shown</p></li>
<li><p><strong>ts_postprep_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
time series after PREP is done.</p></li>
<li><p><strong>psd_postprep_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
PSD after PREP is done.</p></li>
<li><p><strong>psd_postica_png</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the
PSD after PREP and ICA are both done.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.filter_group">
<span class="sig-name descname"><span class="pre">filter_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'eog'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.filter_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters specified channel group to be used as templates for ICA artifact removal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>what</strong> (<em>str</em>) – currently either “eog” or “ecg” - the channel group name</p></li>
<li><p><strong>view_plots</strong> (<em>bool</em>) – flag to view plots</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.getRaw">
<span class="sig-name descname"><span class="pre">getRaw</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_pyprep.Pipeline.getRaw" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Raw EDF object</strong> (<em>preprocessed</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.ica">
<span class="sig-name descname"><span class="pre">ica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.ica" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs ICA on the given EEG segment for both EOG and ECG channels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>view_plots</strong> – flag to show interactive plots</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.prep">
<span class="sig-name descname"><span class="pre">prep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_plots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd_plot_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.prep" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the PREP pipeline to the EEG segment to mark the bad channels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>view_plots</strong> – boolean value to denote if we want to view plots</p></li>
<li><p><strong>ts_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the processed EDF
time series.</p></li>
<li><p><strong>psd_plot_file</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, file to save the plot of the processed EDF
PSD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="do_pyprep.Pipeline.showplot">
<span class="sig-name descname"><span class="pre">showplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_series</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">picks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savefile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#do_pyprep.Pipeline.showplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the time courses and / or power spectrum  of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>title</strong> (<em>str</em>) – the plot title</p></li>
<li><p><strong>time_series</strong> (<em>bool</em>) – whether time series should be plotted</p></li>
<li><p><strong>psd</strong> (<em>bool</em>) – whether power spectrum should be plotted</p></li>
<li><p><strong>picks</strong> (<em>str</em><em> or </em><em>lst</em>) – channels to plot; if <cite>None</cite> (default) -
all channels will be plotted</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – flag to show the plot interactively (execution
is paused)</p></li>
<li><p><strong>savefile</strong> (<em>str</em><em> or </em><em>None</em>) – if not None, the name of the file to save
the plot to.</p></li>
<li><p><strong>dpi</strong> (<em>int</em><em> or </em><em>None</em>) – if not None, the DPI setting for the saved plot.
Ignored if savefile is None.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only one of <cite>time_series</cite> or <cite>psd</cite> should be <cite>True</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-extract_hv_intervals">
<span id="extract-hv-intervals-py"></span><h2>extract_hv_intervals.py<a class="headerlink" href="#module-extract_hv_intervals" title="Permalink to this heading">¶</a></h2>
<p>A script to perform filtering and extraction of hyperventilation (HV)
intervals.</p>
<dl class="py function">
<dt class="sig sig-object py" id="extract_hv_intervals.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#extract_hv_intervals.get_data_folders" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_root, out_root, cluster_job</strong> (<em>str, str, bool</em>) – paths to the root input and output
data folders, and a flag indicating whether host is on CC cluster</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-run_src_reconstr">
<span id="run-src-reconstr-py"></span><h2>run_src_reconstr.py<a class="headerlink" href="#module-run_src_reconstr" title="Permalink to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="run_src_reconstr.JSON_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">JSON_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'src_reconstr_conf.json'</span></em><a class="headerlink" href="#run_src_reconstr.JSON_CONFIG_FILE" title="Permalink to this definition">¶</a></dt>
<dd><p>Default name (without a path) for the JSON file with parameter settings for
the source reconstruction step. This file is expected
to reside in the same folder as this file.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="run_src_reconstr.PYPREP_CONFIG_FILE">
<span class="sig-name descname"><span class="pre">PYPREP_CONFIG_FILE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'pyprep_ica_conf.json'</span></em><a class="headerlink" href="#run_src_reconstr.PYPREP_CONFIG_FILE" title="Permalink to this definition">¶</a></dt>
<dd><p>Name (without a path) for the JSON file with parameter settings for
the PYPREP/ICA step. This file is expected to reside in the same folder
as this script.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="run_src_reconstr.get_data_folders">
<span class="sig-name descname"><span class="pre">get_data_folders</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#run_src_reconstr.get_data_folders" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup input and output data folders depending on the host machine.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_root</strong> (<em>str</em>) – path to the root input folder</p></li>
<li><p><strong>out_root</strong> (<em>str</em>) – path to the root output folder</p></li>
<li><p><strong>fs_dir</strong> (<em>str</em>) – path to the folder with the template subject ‘fsaverage’ data</p></li>
<li><p><strong>cluster_job</strong> (<em>bool</em>) – a flag indicating whether the host is on CC cluster</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-do_src_reconstr">
<span id="do-src-reconstr"></span><h2>do_src_reconstr<a class="headerlink" href="#module-do_src_reconstr" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.beam_extract_label_time_course">
<span class="sig-name descname"><span class="pre">beam_extract_label_time_course</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sensor_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca_flip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.beam_extract_label_time_course" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spatial filter weights and time courses for ROIs (labels) using beamformer
inverse solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sensor_data</strong> (<em>ndarray</em>) – nchan x ntimes; EEG channels time courses</p></li>
<li><p><strong>cov</strong> (<em>ndarray</em>) – nchan x nchan; the sensor time courses covariance matrix</p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of mne.Label objects for the ROIs</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc; beamformer weights for the whole (global) source space</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – a method of constructing a single time course for the ROI; see description
of <cite>mne.extract_label_time_course()</cite> function</p></li>
<li><p><strong>verbose</strong> (<em>str</em>) – verbose mode</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes; ROI time courses</p></li>
<li><p><strong>label_wts</strong> (<em>ndarray</em>) – nchan x nlabels; spatial filter weights for each label</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_beamformer_stc">
<span class="sig-name descname"><span class="pre">compute_beamformer_stc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_beamformer_stc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct source time courses using single source minimum variance
beamformer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the raw data containing only good sensor channels</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>return_stc</strong> (<em>bool</em>) – flag to compute all source time courses and to return
corresponding SourceEstimate object</p></li>
<li><p><strong>beam_type</strong> (<em>str</em>) – beamformer type: one of <cite>‘pz’</cite> (pseudo-Z) or <cite>‘ai’</cite> (activity
index) scalar beamformer can be calculated.</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em>) – tolerance (relative accuracy) in finding the noise_cov trace.</p></li>
<li><p><strong>rcond</strong> (<em>float &gt; 0</em>) – condition for determining rank of the covariance matrix:
singular values less than <cite>max(sing val) * rcond</cite> will be considered zero.</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbose mode (see MNE docs for details)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>stc</strong> (<em>mne.SourceEstimate or None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space, provided return_stc flag is True; None otherwise</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray</em>) – nchan x nchan, sensor covariance matrix adjusted to a nearest
positive definite matrix</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc array of beamformer weights</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – 3 x nsrc array of source orientations</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>, where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_roi_time_courses">
<span class="sig-name descname"><span class="pre">compute_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inv_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca_flip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_roi_time_courses" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute time courses for ROIs (labels).</p>
<p>If <cite>inv_method</cite> is ‘beam’ and <cite>mode</cite> is <cite>pca_flip</cite> - <cite>beam_extract_label_time_course()</cite>
will be used; otherwise a MNE function  mne.extract_label_time_course() will be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inv_method</strong> (<em>str</em>) – inverse method used to create the <cite>stc</cite></p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of mne.Label objects for the ROIs</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – a method of constructing a single time course for ROI - see description
of <a href="#id1"><span class="problematic" id="id2">`</span></a>mne.extract_label_time_course() function.</p></li>
<li><p><strong>stc</strong> (<em>mne.SourceEstimate</em><em> or </em><em>None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space; only needed for non-beamformer reconstructions</p></li>
<li><p><strong>sensor_data</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x ntimes; EEG channels time courses. Must be
specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>cov</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x nchan; the sensor time courses covariance matrix. Must be
specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>W</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchan x nsrc; beamformer weights for the whole (global) source space.
Must be specified for beamformer reconstructions, not needed for others.</p></li>
<li><p><strong>verbose</strong> (<em>str</em>) – verbose mode</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes; ROI time courses</p></li>
<li><p><strong>label_wts</strong> (<em>ndarray or None</em>) – nchan x nlabels; spatial filter weights for each label for
beamformer reconstructions, None for other (min norm) reconstructions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.compute_source_timecourses">
<span class="sig-name descname"><span class="pre">compute_source_timecourses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'beam'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_stc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.compute_source_timecourses" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct source time courses for all sources in the source space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw</strong> (<em>mne.Raw</em>) – the raw data containing only good sensor channels</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – forward solutions</p></li>
<li><p><strong>method</strong> (<em>str</em>) – source reconstruction method; currently only beamformer
(method = ‘beam’) is implemented</p></li>
<li><p><strong>return_stc</strong> (<em>bool</em>) – flag to compute all source time courses and to return
corresponding SourceEstimate object</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – dictionary with method-specific arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>stc</strong> (<em>mne.SourceEstimate or None</em>) – source estimate (reconstructed source time courses) for
a surfaced based source space, if <cite>return_stc = True</cite>, or None otherwise.</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray or None</em>) – nchan x nchan; if <cite>method = ‘beam’</cite>: sensor covariance matrix
adjusted to a nearest positive definite matrix; None otherwise</p></li>
<li><p><strong>W</strong> (<em>ndarray or None</em>) – nchan x nsrc; if <cite>method = ‘beam’</cite>:  array of beamformer weights;
None othewise</p></li>
<li><p><strong>U</strong> (<em>ndarray or None</em>) – 3 x nsrc; if <cite>method = ‘beam’</cite>: array of source orientations;
None otherwise</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>, where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.construct_noise_and_inv_cov">
<span class="sig-name descname"><span class="pre">construct_noise_and_inv_cov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_cov</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.construct_noise_and_inv_cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the forward solutions, construct sensor-level noise covariance
matrix assuming white, randomly oriented uncorrelated sources. Also calculate
pseudo-inverse of the data cov and SNR.</p>
<p>The basic expression for noise covariance is:</p>
<p><cite>cov0 = const * SUM(i=1 to Nsrc){Hx Hx’ + Hy Hy’ + Hz Hz’}</cite></p>
<p>where <cite>Hx,y,z(i)</cite> are forward solutions for i-th source with corresponding
orientations, and <cite>const</cite> is defined so as data_cov - noise_cov is non-negative.</p>
<p>For degenerate data_cov the noise_cov should also be degenerate with a
range subspace coinciding with the range of the data_cov. In this case the
above expression should be replaced with</p>
<p><cite>cov = P * cov0 * P</cite></p>
<p>where <cite>P = data_cov * pinv(data_cov)</cite> is a projector on the <cite>range(data_cov)</cite>.</p>
<p>The trace of the noise_cov is maximized while keeping the difference
<cite>data_cov - noise_cov</cite> non-negative. The tol parameter defines how close to
the upper boundary one should get.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>Forward</em>) – mne Python forward solutions class</p></li>
<li><p><strong>data_cov</strong> (<em>ndarray</em>) – nchan x nchan data covariance matrix</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em>) – tolerance in finding the noise_cov trace.</p></li>
<li><p><strong>rcond</strong> (<em>float &gt; 0</em>) – singular values less than max(sing val) * rcond will
be dropped</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cov</strong> (<em>ndarray</em>) – (nchan x nchan) noise cov matrix, such that the difference
data_cov - noise_cov is non-negatively defined</p></li>
<li><p><strong>inv_cov</strong> (<em>ndarray</em>) – (nchan x nchan) (pseudo-) inverse of the data cov</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – rank of the data covariance</p></li>
<li><p><strong>pz</strong> (<em>float</em>) – psedo-Z = SNR + 1 of the data; <cite>pz=tr(data_cov)/tr(noise_cov)</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.encode_vertex_list">
<span class="sig-name descname"><span class="pre">encode_vertex_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_left</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.encode_vertex_list" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Make left hemi vertex numbers negative or equal to _LEFT_HEMI_ZERO</dt><dd><p>as appropriate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertno</strong> (<em>ndarray</em>) – 1D array of vertex numbers &gt;=0</p></li>
<li><p><strong>is_left</strong> (<em>bool</em>) – <cite>True</cite> for left hemisphere, <cite>False</cite> for right hemisphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vtx</strong> (<em>ndarray</em>) – new vertex list; there are no changes for right hemi vertices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.fwd_file_name">
<span class="sig-name descname"><span class="pre">fwd_file_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scan_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.fwd_file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct forward solution file name base on the source space used</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scan_id</strong> (<em>str</em>) – subject ID (=scan id)</p></li>
<li><p><strong>src_file</strong> (<em>str</em>) – standard template source space name in the form
fsaverage-….-src.fif</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fwd_name</strong> (<em>str</em>) – fwd solutions file name in the form
scan_id-….-fwd.fif</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_beam_weights">
<span class="sig-name descname"><span class="pre">get_beam_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_beam_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get beamformer weights matrix for a set of forward solutions</p>
<p>For each source, calculate a scalar beamformer weight using a formula</p>
<p><cite>w = const * R^(-1) h; h = [Hx, Hy, Hz]*u</cite></p>
<p>where <cite>R</cite> is the data covariance matrix, <cite>h</cite> is a “scalar” lead field corresponding
to the source orientation <cite>u</cite>. The normalization constant is selected depending
on the <cite>units</cite> parameter setting:</p>
<p><cite>units = “source”: const = (h’ R^(-1) h)^(-1)</cite></p>
<p><cite>units = “pz”:     const = [h’ R^(-1) N R^(-1) h]^(-1/2)</cite></p>
<p>In the first case absolute current dipole amplitudes (A*m) will be reconstructed.
In the 2nd case source amplitudes will be normalized on projected noise, effectively
representing source-level signal to noise ratio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>ndarray</em>) – nchan x (3*n_src) array of FS for a set of n_src sources</p></li>
<li><p><strong>inv_cov</strong> (<em>ndarray</em>) – nchan x nchan (pseudo-)inverse of sesnor cov matrix</p></li>
<li><p><strong>noise_cov</strong> (<em>ndarray</em>) – nchan x nchan noise cov matrix</p></li>
<li><p><strong>units</strong> (<em>str</em>) – either “source” or “pz”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc array of beamformer weights</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – 3 x nsrc array of source orientations</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_coms">
<span class="sig-name descname"><span class="pre">get_label_coms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_coms" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate center-of-mass vertices for ROIs
assuming that all vertices in ROI have identical weights.</p>
<p>The ROIs are defined on the ‘fsaverage’ subject’s original
(that is - dense) cortical surface. So are the returned
COM vertex numbers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the labels were restricted to a source space using
a coarser surface than the original FreeSurfer surface, the
returned COMs will also be vertices of this coarser surface.
Still the vertex numbers themselves refer to the original
dense surface. Importantly, “restricted” labels may sometimes
have their <cite>vertices</cite> lists empty. In this case, <strong>an exception
will be thrown</strong>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<em>list</em><em> of </em><em>Label</em>) – list of MNE Label objects</p></li>
<li><p><strong>fs_dir</strong> (<em>str</em>) – pathname to the subject’s directory that contains
the ‘fsaverage’ subject</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>label_coms</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_fwd">
<span class="sig-name descname"><span class="pre">get_label_fwd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_fwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subset of forward solutions corresponding to specified Label (ROI)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>H</strong> (<em>ndarray</em>) – nchan x (3*n_label_src) array of the ROI forward solutions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_pca_weight">
<span class="sig-name descname"><span class="pre">get_label_pca_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_pca_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spatial filter vector <cite>w_pca</cite> such that a single label
(ROI) time course can be found by the expression <cite>w_pca’*b(t)</cite>, where
<cite>b</cite> is a vector of sensor time courses.</p>
<p><em>Explanation</em>. Covariance matrix of all signals that belong to a label is
<cite>R_label = W_label’* R * W_label</cite>, where R is the global sensor covariance and
<cite>W_label = nchan x n_label_src</cite> are label weights.
Let <cite>U0 = n_label_src x 1</cite> be the largest normalized eigenvector of R_label.
Then label time course <cite>s(t)</cite> corresponding to ‘pca_flip’ mode is found as</p>
<p><cite>s(t) = sign * scale * U0’ * W_label’ * b(t)</cite>,</p>
<p>where</p>
<p><cite>scale = sqrt[(trace(R_label)/E0)/n_label_src]</cite>,
<cite>sign = np.sign(U0’*flip)</cite></p>
<p>E0 is the largest eigenvalue of R_label and <cite>flip</cite> is a flip-vector returned by
MNE <cite>label_sign_flip()</cite> function. This scaling assigns the RMS of the powers
of all ROI sources to the returned single time course amplitude. Then it is
clear that the expression for <cite>w_pca</cite> is:</p>
<p><cite>w_pca = sign * scale * W_label * U0, w_pca = nchan x 1</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>ndarray</em>) – nchan x nchan, the global sensor data covariance matrix</p></li>
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the forward solutions object for the whole source space</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc, weights matrix for the whole source space</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>w_pca</strong> (<em>ndarray</em>) – nchan x 1 weight vector for the ROI</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_src_idx">
<span class="sig-name descname"><span class="pre">get_label_src_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_src_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get source indecies for a label (ROI)</p>
<p>Forward solution matrices H and weight matrices W have
columns (or triplets of columns) corresponding to sources
in the whole (left + right hemisphere) source space. At the
same time, the SourceSpaces object has separate source indexing
for each hemisphere, and so does the ROI (label). This function
returns a mapping from label vertices to columns of scalar H and
scalar W.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>idx</strong> (<em>1D array of ints</em>) – n_label_src-dimensional vector of indecies</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_label_wts">
<span class="sig-name descname"><span class="pre">get_label_wts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_label_wts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subset of spatial filter weights corresponding to specified Label (ROI)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwd</strong> (<em>mne.Forward</em>) – the global <cite>Forward</cite> object</p></li>
<li><p><strong>W</strong> (<em>ndarray</em>) – nchan x nsrc, weights matrix for the whole source space</p></li>
<li><p><strong>label</strong> (<em>mne.Label</em>) – the <cite>Label</cite> object for the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W_label</strong> (<em>ndarray</em>) – nchan x (n_label_src) array of ROI weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.get_voxel_coords">
<span class="sig-name descname"><span class="pre">get_voxel_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.get_voxel_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Given vertex numbers, return voxel spatial coordinates for
a surface source space.</p>
<p>NOTE: the coordinate system is that of the source space; it may be
either MRI or head coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>mne.SourceSpaces</em>) – as is</p></li>
<li><p><strong>vertices</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rr</strong> (<em>ndarray</em>) – nvox x 3; coordinates of vertices. <cite>nvox = len(vertices)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.ltc_file_name">
<span class="sig-name descname"><span class="pre">ltc_file_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scan_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.ltc_file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct HDF5 file name for saved ROI time courses based on the source space used</p>
<p>Note that the names of ROIs themselves depend on the atlas (parcellation) used and
will be stored inside the generated HDF5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scan_id</strong> (<em>str</em>) – subject ID (=scan id)</p></li>
<li><p><strong>src_file</strong> (<em>str</em>) – standard template source space name in the form
fsaverage-….-src.fif</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fwd_name</strong> (<em>str</em>) – fwd solutions file name in the form
scan_id-….-ltc.hdf5</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.parse_vertex_list">
<span class="sig-name descname"><span class="pre">parse_vertex_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.parse_vertex_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a mixed list of vertices referring to left and right hemispheres.</p>
<p>The vertex list is in the format described in <cite>get_label_coms()</cite> is split
into separate lists for left and right hemispheres.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vertno</strong> (<em>ndarray</em>) – 1D signed integer array of vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>lh, rh, lh_idx, rh_idx</strong> (<em>tuple</em>) – 1D integer arrays <cite>lh, rh</cite> of left and right
hemisphere vertex numbers; 1D boolean arrays <cite>lh_idx, rh_idx</cite> indicating
locations of left and right vertices in the input list <cite>vertno</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.read_roi_time_courses">
<span class="sig-name descname"><span class="pre">read_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ltc_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.read_roi_time_courses" title="Permalink to this definition">¶</a></dt>
<dd><p>Save ROI (label) time courses and corresponding ROI names in .hdf5
file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ltc_file</strong> (<em>str</em>) – full pathname of the output .hdf5 file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes ROI time courses</p></li>
<li><p><strong>label_names</strong> (<em>ndarray of str</em>) – 1 x nlabels vector of ROI names</p></li>
<li><p><strong>vertno</strong> (<em>ndarray or None</em>) – 1D signed integer array of vertex numbers corresponding
to the ROI COMs. See <cite>parse_vertex_list()</cite> function regarding the vertex
numbers encoding rules.</p></li>
<li><p><strong>rr</strong> (<em>ndarray or None</em>) – nlabels x 3; coordinates of ROI reference locations
in head coordinates</p></li>
<li><p><strong>W</strong> (<em>ndarray or None</em>) – nchans x nlabels; spatial filter weights for each ROI.
Those can be used to reconstruct ROI time courses as <cite>W.T &#64; sensor_data</cite></p></li>
<li><p><strong>pz</strong> (<em>float or None</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>,
where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="do_src_reconstr.write_roi_time_courses">
<span class="sig-name descname"><span class="pre">write_roi_time_courses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ltc_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_tcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#do_src_reconstr.write_roi_time_courses" title="Permalink to this definition">¶</a></dt>
<dd><p>Save ROI (label) time courses and related data in .hdf5
file.</p>
<p>The output file will contain at least two datasets with names ‘label_tcs’ and
‘label_names’. If provided, ROI centers of mass (COMs) vertex numbers
on the FreeSurface’s <cite>fsaverage</cite> cortex surface, ROI COMs in MRI coordinates,
ROI spatial filter weights and the EEG record overall pseudo-Z will also be saved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltc_file</strong> (<em>str</em>) – full pathname of the output .hdf5 file</p></li>
<li><p><strong>label_tcs</strong> (<em>ndarray</em>) – nlabels x ntimes ROI time courses</p></li>
<li><p><strong>label_names</strong> (<em>list</em><em> of </em><em>str</em>) – names of ROIs</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D signed integer array of vertex numbers corresponding
to the ROI COMs. See <cite>parse_vertex_list()</cite> function regarding the vertex
numbers encoding rules.</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nlabels x 3; coordinates of ROI reference locations
in head coordinates</p></li>
<li><p><strong>W</strong> (<em>ndarray</em><em> or </em><em>None</em>) – nchans x nlabels; spatial filter weights for each ROI.
Those can be used to reconstruct ROI time courses as <cite>W.T &#64; sensor_data</cite></p></li>
<li><p><strong>pz</strong> (<em>float</em><em> or </em><em>None</em>) – data’s pseudo-Z found as <cite>pz = trace(R)/tr(N)</cite>,
where <cite>N</cite> is the noise covariance</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-view_raw_eeg">
<span id="view-raw-eeg"></span><h2>view_raw_eeg<a class="headerlink" href="#module-view_raw_eeg" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-view_inflated_brain_data">
<span id="view-inflated-brain-data"></span><h2>view_inflated_brain_data<a class="headerlink" href="#module-view_inflated_brain_data" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.expand_data_to_rois">
<span class="sig-name descname"><span class="pre">expand_data_to_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.expand_data_to_rois" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand ROI single data values to all ROI vertices.</p>
<p>For example, when one has one value per ROI in the atlas, these values
will be properly extended to all vertices of hemisphere surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>ndarray</em>) – 1D array, <cite>shape = (nlabels,)</cite>; data values
assigned to ROIs (labels)
vertex values</p></li>
<li><p><strong>labels</strong> (<em>list</em>) – a list of <cite>nlabels</cite> ROI Label objects</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>vdata</strong> (<em>ndarray</em>) – 1D array; data values for all vertices in all labels</p></li>
<li><p><strong>vertices</strong> (<em>ndarray</em>) – 1D array; vertex numbers for each data value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.plot_rr">
<span class="sig-name descname"><span class="pre">plot_rr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.plot_rr" title="Permalink to this definition">¶</a></dt>
<dd><p>Display points specified by 3D spatial positions on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em>) – an instance of MNE Brain class</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em>) – <cite>npoints x 3</cite> array of MRI coordinates, in meters. It is assumed that
points with negative <cite>x</cite> are referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Generally this is not exactly so
but should be correct for the <cite>fsaverage</cite> template.</p></li>
<li><p><strong>map_to_cortex</strong> (<em>Bool</em>) – flag whether foci will be mapped to the closest vertex
on the cortical surface, or left as is. Ignored when vertno is provided.
Note that if <cite>map_to_cortex == False</cite> rr’s will never land onto the
inflated surface even if they do belong to the original (not inflated) cortical
surface.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color</strong> (<em>color</em>) – color of dots in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – opacity in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.plot_vertices">
<span class="sig-name descname"><span class="pre">plot_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.plot_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Display points specified by vertex numbers on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em>) – an instance of MNE Brain class</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color</strong> (<em>color</em>) – color of dots in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – opacity in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>None</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="view_inflated_brain_data.view_inflated_brain_data">
<span class="sig-name descname"><span class="pre">view_inflated_brain_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atlas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_atlas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'both'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbar_lims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rois_to_mark</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subjects_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_dots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_cortex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inflated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs_brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#view_inflated_brain_data.view_inflated_brain_data" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility for displaying data on the brain surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>Brain</em><em> or </em><em>None</em>) – an instance of the Brain class. If supplied,
it will be used for plotting, otherwise a new one will be created.</p></li>
<li><p><strong>atlas</strong> (<em>str</em><em> or </em><em>None</em>) – name of the parcellation to diplay</p></li>
<li><p><strong>show_atlas</strong> (<em>bool</em>) – if <cite>True</cite> parcellation will be displayed</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – the hemisphere from which to read the parcellation,
can be ‘lh’, ‘rh’, or ‘both’.</p></li>
<li><p><strong>title</strong> (<em>str</em><em> or </em><em>None</em>) – a title for the plot.</p></li>
<li><p><strong>data</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D array of <cite>nvertno</cite> floating point values, where
<cite>nvertno = len(vertno)</cite>. If data is not <cite>None</cite>, <cite>vertno</cite> should also
be given. <cite>data</cite> and <cite>vertno</cite> should have the same length.</p></li>
<li><p><strong>cbar_lims</strong> (<em>(</em><em>float</em><em>,</em><em>float</em><em>) or </em><em>None</em>) – (fmin, fmax) color bar limits for the data.
If <cite>None</cite>, those will be set automatically.</p></li>
<li><p><strong>colormap</strong> (<em>str</em><em>, </em><em>list</em><em> of </em><em>color</em><em>, or </em><em>array</em>) – as is. Typically a string defining
the palette name, or ‘auto’. See
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em>
for details and other options.</p></li>
<li><p><strong>alpha_data</strong> (<em>float</em>) – opacity of the data overlay on the cortex surface</p></li>
<li><p><strong>smoothing_steps</strong> (<em>int</em><em> or </em><em>'Nearest'</em><em> or </em><em>None</em>) – smoothing when plotting data. <cite>int</cite>
value explicitly sets the number of vertices for smoothing. For other
settings see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em></p></li>
<li><p><strong>rois_to_mark</strong> (<em>list</em><em> or </em><em>None</em>) – if supplied, a list of names of ROIs (labels)
or a list of Label objects. In the first case <cite>atlas</cite> cannot be <cite>None</cite>,
and the name should belong to this atlas. In the 2nd case a ROI from
any surface atlas can be displayed; mind not using <cite>Label</cite> objects
restricted to a (coarse) source space - those won’t show up correctly.
The specified ROIs will be shown with thicker borders.</p></li>
<li><p><strong>vertno</strong> (<em>ndarray</em><em> or </em><em>None</em>) – 1D signed integer array for COM vertex numbers, with
NEGATIVE numbers referring to the LEFT hemisphere, and non-negative
(including 0) - to the right hemisphere. Negative vertex with number
_LEFT_HEMI_ZERO is interpreted as vertex 0 of the left hemisphere.</p></li>
<li><p><strong>show_vertices</strong> (<em>bool</em>) – If <cite>True</cite>, the vertices pointed to by vertno will be
plotted. Default <cite>False</cite>.</p></li>
<li><p><strong>rr</strong> (<em>ndarray</em><em> or </em><em>None</em>) – <cite>nr x 3</cite>; a list of locations in MRI coordinates to plot. Those
will be projected to the nearest cortex location if <cite>map_to_cortex</cite> is <cite>True</cite>.
Importantly, <strong>`rr`’s are NOT “inflated” when plotted</strong>. Specifically, <strong>if
the inflated surface is used (Default), and `map_to_cortex` is `False`,
then points that actually belong to the surface will be displayed off
the surface</strong>. In view of this an exception is thrown when trying to
plot rr’s with <cite>inflated = True</cite> and <cite>map_to_cortex = False</cite>. Use a
non-inflated surface to properly display rr’s relative to the brain.</p></li>
<li><p><strong>map_to_cortex</strong> (<em>bool</em>) – flag whether rr’s will be mapped to the closest vertex
on the cortical surface, of left as is.</p></li>
<li><p><strong>subjects_dir</strong> (<em>str</em>) – a pathname to the folder containing the
FreeSurfer results for a subject whose brain surface is used for display.
Typically this is the <cite>fsaverage</cite> subject template data folder.</p></li>
<li><p><strong>scale_factor</strong> (<em>float</em>) – size of plotted dots relative to 1 cm</p></li>
<li><p><strong>color_dots</strong> (<em>color</em>) – color of plotted spheres (dots) for vertices (if shown)
or rr’s, in any matplotlib form: string, RGB, hex, etc</p></li>
<li><p><strong>alpha_cortex</strong> (<em>float</em>) – opacity of the cortex surface and the dots (spheres) if
vertices or rr’s are plotted; should be in [0, 1] interval</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – the resolution of the dot spheres</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Display the window as soon as it is ready. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>block</strong> (<em>bool</em>) – If <cite>True</cite>, start the Qt application event loop. Default to <cite>False</cite>.</p></li>
<li><p><strong>inflated</strong> (<em>bool</em>) – If <cite>True</cite>, (default) show inflated pial surface.</p></li>
<li><p><strong>kwargs_brain</strong> (<em>dict</em><em> or </em><em>None</em>) – if needed, more arguments to the Brain class constructor
in addition to those listed above; see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html</em>
for details.</p></li>
<li><p><strong>kwargs_data</strong> (<em>dict</em>) – if needed, more arguments to the Brain.add_data() method
in addition to those listed above; see
<em>https://mne.tools/stable/generated/mne.viz.Brain.html#mne.viz.Brain.add_data</em>
for details.</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em> or </em><em>None</em>) – verbosity level; one of ‘DEBUG’, ‘INFO’,
‘WARNING’, ‘ERROR’, ‘CRITICAL’ or None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>brain</strong> (<em>Brain</em>) – the new or old instance of the Brain class</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-plot_alpha_power">
<span id="plot-alpha-power"></span><h2>plot_alpha_power<a class="headerlink" href="#module-plot_alpha_power" title="Permalink to this heading">¶</a></h2>
<p>Display alpha-band source power distribution on the cortex surface</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">eegfh</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">EEG preprocessing pipeline for FHA EDF dataset</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Classes and functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-run_filtering_segmentation">run_filtering_segmentation.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-edf_preprocessing">edf_preprocessing.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-individual_func">individual_func.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-do_pyprep">do_pyprep.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-extract_hv_intervals">extract_hv_intervals.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-run_src_reconstr">run_src_reconstr.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-do_src_reconstr">do_src_reconstr</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-view_raw_eeg">view_raw_eeg</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-view_inflated_brain_data">view_inflated_brain_data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-plot_alpha_power">plot_alpha_power</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="README.html" title="previous chapter">EEG preprocessing pipeline for FHA EDF dataset</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, AM.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/code.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>